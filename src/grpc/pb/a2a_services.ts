// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: a2a_services.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "./google/protobuf/empty.js";
import { Struct } from "./google/protobuf/struct.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

export const protobufPackage = "a2a.v1";

import * as pb from "../../types/pb/a2a_types.js";

export type SendMessageConfiguration = pb.SendMessageConfiguration;
export type Task = pb.Task;
export type TaskStatus = pb.TaskStatus;
export type Part = pb.Part;
export type FilePart = pb.FilePart;
export type DataPart = pb.DataPart;
export type Message = pb.Message;
export type Artifact = pb.Artifact;
export type TaskStatusUpdateEvent = pb.TaskStatusUpdateEvent;
export type TaskArtifactUpdateEvent = pb.TaskArtifactUpdateEvent;
export type PushNotificationConfig = pb.PushNotificationConfig;
export type AuthenticationInfo = pb.AuthenticationInfo;
export type AgentInterface = pb.AgentInterface;
export type AgentCard = pb.AgentCard;
export type AgentCard_SecuritySchemesEntry = pb.AgentCard_SecuritySchemesEntry;
export type AgentProvider = pb.AgentProvider;
export type AgentCapabilities = pb.AgentCapabilities;
export type AgentExtension = pb.AgentExtension;
export type AgentSkill = pb.AgentSkill;
export type AgentCardSignature = pb.AgentCardSignature;
export type TaskPushNotificationConfig = pb.TaskPushNotificationConfig;
export type StringList = pb.StringList;
export type Security = pb.Security;
export type Security_SchemesEntry = pb.Security_SchemesEntry;
export type SecurityScheme = pb.SecurityScheme;
export type APIKeySecurityScheme = pb.APIKeySecurityScheme;
export type HTTPAuthSecurityScheme = pb.HTTPAuthSecurityScheme;
export type OAuth2SecurityScheme = pb.OAuth2SecurityScheme;
export type OpenIdConnectSecurityScheme = pb.OpenIdConnectSecurityScheme;
export type MutualTlsSecurityScheme = pb.MutualTlsSecurityScheme;
export type OAuthFlows = pb.OAuthFlows;
export type AuthorizationCodeOAuthFlow = pb.AuthorizationCodeOAuthFlow;
export type AuthorizationCodeOAuthFlow_ScopesEntry = pb.AuthorizationCodeOAuthFlow_ScopesEntry;
export type ClientCredentialsOAuthFlow = pb.ClientCredentialsOAuthFlow;
export type ClientCredentialsOAuthFlow_ScopesEntry = pb.ClientCredentialsOAuthFlow_ScopesEntry;
export type ImplicitOAuthFlow = pb.ImplicitOAuthFlow;
export type ImplicitOAuthFlow_ScopesEntry = pb.ImplicitOAuthFlow_ScopesEntry;
export type PasswordOAuthFlow = pb.PasswordOAuthFlow;
export type PasswordOAuthFlow_ScopesEntry = pb.PasswordOAuthFlow_ScopesEntry;
export type SendMessageRequest = pb.SendMessageRequest;
export type GetTaskRequest = pb.GetTaskRequest;
export type CancelTaskRequest = pb.CancelTaskRequest;
export type GetTaskPushNotificationConfigRequest = pb.GetTaskPushNotificationConfigRequest;
export type DeleteTaskPushNotificationConfigRequest = pb.DeleteTaskPushNotificationConfigRequest;
export type CreateTaskPushNotificationConfigRequest = pb.CreateTaskPushNotificationConfigRequest;
export type TaskSubscriptionRequest = pb.TaskSubscriptionRequest;
export type ListTaskPushNotificationConfigRequest = pb.ListTaskPushNotificationConfigRequest;
export type GetAgentCardRequest = pb.GetAgentCardRequest;
export type SendMessageResponse = pb.SendMessageResponse;
export type StreamResponse = pb.StreamResponse;
export type ListTaskPushNotificationConfigResponse = pb.ListTaskPushNotificationConfigResponse;

function createBaseSendMessageConfiguration(): SendMessageConfiguration {
  return { acceptedOutputModes: [], pushNotification: undefined, historyLength: 0, blocking: false };
}

export const SendMessageConfiguration: MessageFns<SendMessageConfiguration> = {
  encode(message: SendMessageConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.acceptedOutputModes) {
      writer.uint32(10).string(v!);
    }
    if (message.pushNotification !== undefined) {
      PushNotificationConfig.encode(message.pushNotification, writer.uint32(18).fork()).join();
    }
    if (message.historyLength !== 0) {
      writer.uint32(24).int32(message.historyLength);
    }
    if (message.blocking !== false) {
      writer.uint32(32).bool(message.blocking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.acceptedOutputModes.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pushNotification = PushNotificationConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.historyLength = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.blocking = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTask(): Task {
  return { id: "", contextId: "", status: undefined, artifacts: [], history: [], metadata: undefined };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contextId !== "") {
      writer.uint32(18).string(message.contextId);
    }
    if (message.status !== undefined) {
      TaskStatus.encode(message.status, writer.uint32(26).fork()).join();
    }
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.history) {
      Message.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contextId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = TaskStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.history.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTaskStatus(): TaskStatus {
  return { state: 0, update: undefined, timestamp: undefined };
}

export const TaskStatus: MessageFns<TaskStatus> = {
  encode(message: TaskStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.update !== undefined) {
      Message.encode(message.update, writer.uint32(18).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.update = Message.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePart(): Part {
  return { part: undefined };
}

export const Part: MessageFns<Part> = {
  encode(message: Part, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.part?.$case) {
      case "text":
        writer.uint32(10).string(message.part.value);
        break;
      case "file":
        FilePart.encode(message.part.value, writer.uint32(18).fork()).join();
        break;
      case "data":
        DataPart.encode(message.part.value, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Part {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.part = { $case: "text", value: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.part = { $case: "file", value: FilePart.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.part = { $case: "data", value: DataPart.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFilePart(): FilePart {
  return { file: undefined, mimeType: "" };
}

export const FilePart: MessageFns<FilePart> = {
  encode(message: FilePart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.file?.$case) {
      case "fileWithUri":
        writer.uint32(10).string(message.file.value);
        break;
      case "fileWithBytes":
        writer.uint32(18).bytes(message.file.value);
        break;
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilePart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.file = { $case: "fileWithUri", value: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.file = { $case: "fileWithBytes", value: Buffer.from(reader.bytes()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDataPart(): DataPart {
  return { data: undefined };
}

export const DataPart: MessageFns<DataPart> = {
  encode(message: DataPart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataPart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataPart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMessage(): Message {
  return { messageId: "", contextId: "", taskId: "", role: 0, content: [], metadata: undefined, extensions: [] };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.contextId !== "") {
      writer.uint32(18).string(message.contextId);
    }
    if (message.taskId !== "") {
      writer.uint32(26).string(message.taskId);
    }
    if (message.role !== 0) {
      writer.uint32(32).int32(message.role);
    }
    for (const v of message.content) {
      Part.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    for (const v of message.extensions) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contextId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content.push(Part.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.extensions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseArtifact(): Artifact {
  return { artifactId: "", name: "", description: "", parts: [], metadata: undefined, extensions: [] };
}

export const Artifact: MessageFns<Artifact> = {
  encode(message: Artifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.parts) {
      Part.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    for (const v of message.extensions) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Artifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parts.push(Part.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.extensions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTaskStatusUpdateEvent(): TaskStatusUpdateEvent {
  return { taskId: "", contextId: "", status: undefined, final: false, metadata: undefined };
}

export const TaskStatusUpdateEvent: MessageFns<TaskStatusUpdateEvent> = {
  encode(message: TaskStatusUpdateEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.contextId !== "") {
      writer.uint32(18).string(message.contextId);
    }
    if (message.status !== undefined) {
      TaskStatus.encode(message.status, writer.uint32(26).fork()).join();
    }
    if (message.final !== false) {
      writer.uint32(32).bool(message.final);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskStatusUpdateEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStatusUpdateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contextId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = TaskStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.final = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTaskArtifactUpdateEvent(): TaskArtifactUpdateEvent {
  return { taskId: "", contextId: "", artifact: undefined, append: false, lastChunk: false, metadata: undefined };
}

export const TaskArtifactUpdateEvent: MessageFns<TaskArtifactUpdateEvent> = {
  encode(message: TaskArtifactUpdateEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.contextId !== "") {
      writer.uint32(18).string(message.contextId);
    }
    if (message.artifact !== undefined) {
      Artifact.encode(message.artifact, writer.uint32(26).fork()).join();
    }
    if (message.append !== false) {
      writer.uint32(32).bool(message.append);
    }
    if (message.lastChunk !== false) {
      writer.uint32(40).bool(message.lastChunk);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskArtifactUpdateEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskArtifactUpdateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contextId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.artifact = Artifact.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.append = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastChunk = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePushNotificationConfig(): PushNotificationConfig {
  return { id: "", url: "", token: "", authentication: undefined };
}

export const PushNotificationConfig: MessageFns<PushNotificationConfig> = {
  encode(message: PushNotificationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    if (message.authentication !== undefined) {
      AuthenticationInfo.encode(message.authentication, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PushNotificationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushNotificationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authentication = AuthenticationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthenticationInfo(): AuthenticationInfo {
  return { schemes: [], credentials: "" };
}

export const AuthenticationInfo: MessageFns<AuthenticationInfo> = {
  encode(message: AuthenticationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schemes) {
      writer.uint32(10).string(v!);
    }
    if (message.credentials !== "") {
      writer.uint32(18).string(message.credentials);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemes.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.credentials = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentInterface(): AgentInterface {
  return { url: "", transport: "" };
}

export const AgentInterface: MessageFns<AgentInterface> = {
  encode(message: AgentInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.transport !== "") {
      writer.uint32(18).string(message.transport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transport = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentCard(): AgentCard {
  return {
    protocolVersion: "",
    name: "",
    description: "",
    url: "",
    preferredTransport: "",
    additionalInterfaces: [],
    provider: undefined,
    version: "",
    documentationUrl: "",
    capabilities: undefined,
    securitySchemes: {},
    security: [],
    defaultInputModes: [],
    defaultOutputModes: [],
    skills: [],
    supportsAuthenticatedExtendedCard: false,
    signatures: [],
  };
}

export const AgentCard: MessageFns<AgentCard> = {
  encode(message: AgentCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolVersion !== "") {
      writer.uint32(130).string(message.protocolVersion);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.preferredTransport !== "") {
      writer.uint32(114).string(message.preferredTransport);
    }
    for (const v of message.additionalInterfaces) {
      AgentInterface.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.provider !== undefined) {
      AgentProvider.encode(message.provider, writer.uint32(34).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (message.documentationUrl !== "") {
      writer.uint32(50).string(message.documentationUrl);
    }
    if (message.capabilities !== undefined) {
      AgentCapabilities.encode(message.capabilities, writer.uint32(58).fork()).join();
    }
    Object.entries(message.securitySchemes).forEach(([key, value]) => {
      AgentCard_SecuritySchemesEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    for (const v of message.security) {
      Security.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.defaultInputModes) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.defaultOutputModes) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.skills) {
      AgentSkill.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.supportsAuthenticatedExtendedCard !== false) {
      writer.uint32(104).bool(message.supportsAuthenticatedExtendedCard);
    }
    for (const v of message.signatures) {
      AgentCardSignature.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.protocolVersion = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.preferredTransport = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.additionalInterfaces.push(AgentInterface.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.provider = AgentProvider.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.documentationUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.capabilities = AgentCapabilities.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = AgentCard_SecuritySchemesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.securitySchemes[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.security.push(Security.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.defaultInputModes.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.defaultOutputModes.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.skills.push(AgentSkill.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.supportsAuthenticatedExtendedCard = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.signatures.push(AgentCardSignature.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentCard_SecuritySchemesEntry(): AgentCard_SecuritySchemesEntry {
  return { key: "", value: undefined };
}

export const AgentCard_SecuritySchemesEntry: MessageFns<AgentCard_SecuritySchemesEntry> = {
  encode(message: AgentCard_SecuritySchemesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecurityScheme.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentCard_SecuritySchemesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCard_SecuritySchemesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SecurityScheme.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentProvider(): AgentProvider {
  return { url: "", organization: "" };
}

export const AgentProvider: MessageFns<AgentProvider> = {
  encode(message: AgentProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.organization !== "") {
      writer.uint32(18).string(message.organization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organization = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentCapabilities(): AgentCapabilities {
  return { streaming: false, pushNotifications: false, extensions: [] };
}

export const AgentCapabilities: MessageFns<AgentCapabilities> = {
  encode(message: AgentCapabilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streaming !== false) {
      writer.uint32(8).bool(message.streaming);
    }
    if (message.pushNotifications !== false) {
      writer.uint32(16).bool(message.pushNotifications);
    }
    for (const v of message.extensions) {
      AgentExtension.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentCapabilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.streaming = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pushNotifications = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.extensions.push(AgentExtension.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentExtension(): AgentExtension {
  return { uri: "", description: "", required: false, params: undefined };
}

export const AgentExtension: MessageFns<AgentExtension> = {
  encode(message: AgentExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentSkill(): AgentSkill {
  return { id: "", name: "", description: "", tags: [], examples: [], inputModes: [], outputModes: [], security: [] };
}

export const AgentSkill: MessageFns<AgentSkill> = {
  encode(message: AgentSkill, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.examples) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.inputModes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.outputModes) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.security) {
      Security.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentSkill {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentSkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.examples.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputModes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputModes.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.security.push(Security.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAgentCardSignature(): AgentCardSignature {
  return { protected: "", signature: "", header: undefined };
}

export const AgentCardSignature: MessageFns<AgentCardSignature> = {
  encode(message: AgentCardSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protected !== "") {
      writer.uint32(10).string(message.protected);
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    if (message.header !== undefined) {
      Struct.encode(Struct.wrap(message.header), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentCardSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCardSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.protected = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.header = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTaskPushNotificationConfig(): TaskPushNotificationConfig {
  return { name: "", pushNotificationConfig: undefined };
}

export const TaskPushNotificationConfig: MessageFns<TaskPushNotificationConfig> = {
  encode(message: TaskPushNotificationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pushNotificationConfig !== undefined) {
      PushNotificationConfig.encode(message.pushNotificationConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskPushNotificationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskPushNotificationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pushNotificationConfig = PushNotificationConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStringList(): StringList {
  return { list: [] };
}

export const StringList: MessageFns<StringList> = {
  encode(message: StringList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.list) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.list.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSecurity(): Security {
  return { schemes: {} };
}

export const Security: MessageFns<Security> = {
  encode(message: Security, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.schemes).forEach(([key, value]) => {
      Security_SchemesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Security {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Security_SchemesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.schemes[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSecurity_SchemesEntry(): Security_SchemesEntry {
  return { key: "", value: undefined };
}

export const Security_SchemesEntry: MessageFns<Security_SchemesEntry> = {
  encode(message: Security_SchemesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      StringList.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Security_SchemesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurity_SchemesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = StringList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSecurityScheme(): SecurityScheme {
  return { scheme: undefined };
}

export const SecurityScheme: MessageFns<SecurityScheme> = {
  encode(message: SecurityScheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.scheme?.$case) {
      case "apiKeySecurityScheme":
        APIKeySecurityScheme.encode(message.scheme.value, writer.uint32(10).fork()).join();
        break;
      case "httpAuthSecurityScheme":
        HTTPAuthSecurityScheme.encode(message.scheme.value, writer.uint32(18).fork()).join();
        break;
      case "oauth2SecurityScheme":
        OAuth2SecurityScheme.encode(message.scheme.value, writer.uint32(26).fork()).join();
        break;
      case "openIdConnectSecurityScheme":
        OpenIdConnectSecurityScheme.encode(message.scheme.value, writer.uint32(34).fork()).join();
        break;
      case "mtlsSecurityScheme":
        MutualTlsSecurityScheme.encode(message.scheme.value, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityScheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scheme = {
            $case: "apiKeySecurityScheme",
            value: APIKeySecurityScheme.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scheme = {
            $case: "httpAuthSecurityScheme",
            value: HTTPAuthSecurityScheme.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheme = {
            $case: "oauth2SecurityScheme",
            value: OAuth2SecurityScheme.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scheme = {
            $case: "openIdConnectSecurityScheme",
            value: OpenIdConnectSecurityScheme.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheme = {
            $case: "mtlsSecurityScheme",
            value: MutualTlsSecurityScheme.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAPIKeySecurityScheme(): APIKeySecurityScheme {
  return { description: "", location: "", name: "" };
}

export const APIKeySecurityScheme: MessageFns<APIKeySecurityScheme> = {
  encode(message: APIKeySecurityScheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): APIKeySecurityScheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPIKeySecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHTTPAuthSecurityScheme(): HTTPAuthSecurityScheme {
  return { description: "", scheme: "", bearerFormat: "" };
}

export const HTTPAuthSecurityScheme: MessageFns<HTTPAuthSecurityScheme> = {
  encode(message: HTTPAuthSecurityScheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.scheme !== "") {
      writer.uint32(18).string(message.scheme);
    }
    if (message.bearerFormat !== "") {
      writer.uint32(26).string(message.bearerFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPAuthSecurityScheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPAuthSecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bearerFormat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOAuth2SecurityScheme(): OAuth2SecurityScheme {
  return { description: "", flows: undefined, oauth2MetadataUrl: "" };
}

export const OAuth2SecurityScheme: MessageFns<OAuth2SecurityScheme> = {
  encode(message: OAuth2SecurityScheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.flows !== undefined) {
      OAuthFlows.encode(message.flows, writer.uint32(18).fork()).join();
    }
    if (message.oauth2MetadataUrl !== "") {
      writer.uint32(26).string(message.oauth2MetadataUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2SecurityScheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2SecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.flows = OAuthFlows.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oauth2MetadataUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOpenIdConnectSecurityScheme(): OpenIdConnectSecurityScheme {
  return { description: "", openIdConnectUrl: "" };
}

export const OpenIdConnectSecurityScheme: MessageFns<OpenIdConnectSecurityScheme> = {
  encode(message: OpenIdConnectSecurityScheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.openIdConnectUrl !== "") {
      writer.uint32(18).string(message.openIdConnectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenIdConnectSecurityScheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenIdConnectSecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.openIdConnectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMutualTlsSecurityScheme(): MutualTlsSecurityScheme {
  return { description: "" };
}

export const MutualTlsSecurityScheme: MessageFns<MutualTlsSecurityScheme> = {
  encode(message: MutualTlsSecurityScheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutualTlsSecurityScheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutualTlsSecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOAuthFlows(): OAuthFlows {
  return { flow: undefined };
}

export const OAuthFlows: MessageFns<OAuthFlows> = {
  encode(message: OAuthFlows, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.flow?.$case) {
      case "authorizationCode":
        AuthorizationCodeOAuthFlow.encode(message.flow.value, writer.uint32(10).fork()).join();
        break;
      case "clientCredentials":
        ClientCredentialsOAuthFlow.encode(message.flow.value, writer.uint32(18).fork()).join();
        break;
      case "implicit":
        ImplicitOAuthFlow.encode(message.flow.value, writer.uint32(26).fork()).join();
        break;
      case "password":
        PasswordOAuthFlow.encode(message.flow.value, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthFlows {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthFlows();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flow = {
            $case: "authorizationCode",
            value: AuthorizationCodeOAuthFlow.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.flow = {
            $case: "clientCredentials",
            value: ClientCredentialsOAuthFlow.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.flow = { $case: "implicit", value: ImplicitOAuthFlow.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.flow = { $case: "password", value: PasswordOAuthFlow.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthorizationCodeOAuthFlow(): AuthorizationCodeOAuthFlow {
  return { authorizationUrl: "", tokenUrl: "", refreshUrl: "", scopes: {} };
}

export const AuthorizationCodeOAuthFlow: MessageFns<AuthorizationCodeOAuthFlow> = {
  encode(message: AuthorizationCodeOAuthFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizationUrl !== "") {
      writer.uint32(10).string(message.authorizationUrl);
    }
    if (message.tokenUrl !== "") {
      writer.uint32(18).string(message.tokenUrl);
    }
    if (message.refreshUrl !== "") {
      writer.uint32(26).string(message.refreshUrl);
    }
    Object.entries(message.scopes).forEach(([key, value]) => {
      AuthorizationCodeOAuthFlow_ScopesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationCodeOAuthFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationCodeOAuthFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AuthorizationCodeOAuthFlow_ScopesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.scopes[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthorizationCodeOAuthFlow_ScopesEntry(): AuthorizationCodeOAuthFlow_ScopesEntry {
  return { key: "", value: "" };
}

export const AuthorizationCodeOAuthFlow_ScopesEntry: MessageFns<AuthorizationCodeOAuthFlow_ScopesEntry> = {
  encode(message: AuthorizationCodeOAuthFlow_ScopesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationCodeOAuthFlow_ScopesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationCodeOAuthFlow_ScopesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClientCredentialsOAuthFlow(): ClientCredentialsOAuthFlow {
  return { tokenUrl: "", refreshUrl: "", scopes: {} };
}

export const ClientCredentialsOAuthFlow: MessageFns<ClientCredentialsOAuthFlow> = {
  encode(message: ClientCredentialsOAuthFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenUrl !== "") {
      writer.uint32(10).string(message.tokenUrl);
    }
    if (message.refreshUrl !== "") {
      writer.uint32(18).string(message.refreshUrl);
    }
    Object.entries(message.scopes).forEach(([key, value]) => {
      ClientCredentialsOAuthFlow_ScopesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientCredentialsOAuthFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientCredentialsOAuthFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClientCredentialsOAuthFlow_ScopesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.scopes[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClientCredentialsOAuthFlow_ScopesEntry(): ClientCredentialsOAuthFlow_ScopesEntry {
  return { key: "", value: "" };
}

export const ClientCredentialsOAuthFlow_ScopesEntry: MessageFns<ClientCredentialsOAuthFlow_ScopesEntry> = {
  encode(message: ClientCredentialsOAuthFlow_ScopesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientCredentialsOAuthFlow_ScopesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientCredentialsOAuthFlow_ScopesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImplicitOAuthFlow(): ImplicitOAuthFlow {
  return { authorizationUrl: "", refreshUrl: "", scopes: {} };
}

export const ImplicitOAuthFlow: MessageFns<ImplicitOAuthFlow> = {
  encode(message: ImplicitOAuthFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizationUrl !== "") {
      writer.uint32(10).string(message.authorizationUrl);
    }
    if (message.refreshUrl !== "") {
      writer.uint32(18).string(message.refreshUrl);
    }
    Object.entries(message.scopes).forEach(([key, value]) => {
      ImplicitOAuthFlow_ScopesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImplicitOAuthFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImplicitOAuthFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ImplicitOAuthFlow_ScopesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.scopes[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImplicitOAuthFlow_ScopesEntry(): ImplicitOAuthFlow_ScopesEntry {
  return { key: "", value: "" };
}

export const ImplicitOAuthFlow_ScopesEntry: MessageFns<ImplicitOAuthFlow_ScopesEntry> = {
  encode(message: ImplicitOAuthFlow_ScopesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImplicitOAuthFlow_ScopesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImplicitOAuthFlow_ScopesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePasswordOAuthFlow(): PasswordOAuthFlow {
  return { tokenUrl: "", refreshUrl: "", scopes: {} };
}

export const PasswordOAuthFlow: MessageFns<PasswordOAuthFlow> = {
  encode(message: PasswordOAuthFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenUrl !== "") {
      writer.uint32(10).string(message.tokenUrl);
    }
    if (message.refreshUrl !== "") {
      writer.uint32(18).string(message.refreshUrl);
    }
    Object.entries(message.scopes).forEach(([key, value]) => {
      PasswordOAuthFlow_ScopesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PasswordOAuthFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasswordOAuthFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = PasswordOAuthFlow_ScopesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.scopes[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePasswordOAuthFlow_ScopesEntry(): PasswordOAuthFlow_ScopesEntry {
  return { key: "", value: "" };
}

export const PasswordOAuthFlow_ScopesEntry: MessageFns<PasswordOAuthFlow_ScopesEntry> = {
  encode(message: PasswordOAuthFlow_ScopesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PasswordOAuthFlow_ScopesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasswordOAuthFlow_ScopesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { request: undefined, configuration: undefined, metadata: undefined };
}

export const SendMessageRequest: MessageFns<SendMessageRequest> = {
  encode(message: SendMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      Message.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.configuration !== undefined) {
      SendMessageConfiguration.encode(message.configuration, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = Message.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configuration = SendMessageConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTaskRequest(): GetTaskRequest {
  return { name: "", historyLength: 0 };
}

export const GetTaskRequest: MessageFns<GetTaskRequest> = {
  encode(message: GetTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.historyLength !== 0) {
      writer.uint32(16).int32(message.historyLength);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.historyLength = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelTaskRequest(): CancelTaskRequest {
  return { name: "" };
}

export const CancelTaskRequest: MessageFns<CancelTaskRequest> = {
  encode(message: CancelTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTaskPushNotificationConfigRequest(): GetTaskPushNotificationConfigRequest {
  return { name: "" };
}

export const GetTaskPushNotificationConfigRequest: MessageFns<GetTaskPushNotificationConfigRequest> = {
  encode(message: GetTaskPushNotificationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskPushNotificationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskPushNotificationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteTaskPushNotificationConfigRequest(): DeleteTaskPushNotificationConfigRequest {
  return { name: "" };
}

export const DeleteTaskPushNotificationConfigRequest: MessageFns<DeleteTaskPushNotificationConfigRequest> = {
  encode(message: DeleteTaskPushNotificationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTaskPushNotificationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTaskPushNotificationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTaskPushNotificationConfigRequest(): CreateTaskPushNotificationConfigRequest {
  return { parent: "", configId: "", config: undefined };
}

export const CreateTaskPushNotificationConfigRequest: MessageFns<CreateTaskPushNotificationConfigRequest> = {
  encode(message: CreateTaskPushNotificationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.configId !== "") {
      writer.uint32(18).string(message.configId);
    }
    if (message.config !== undefined) {
      TaskPushNotificationConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskPushNotificationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskPushNotificationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config = TaskPushNotificationConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTaskSubscriptionRequest(): TaskSubscriptionRequest {
  return { name: "" };
}

export const TaskSubscriptionRequest: MessageFns<TaskSubscriptionRequest> = {
  encode(message: TaskSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTaskPushNotificationConfigRequest(): ListTaskPushNotificationConfigRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTaskPushNotificationConfigRequest: MessageFns<ListTaskPushNotificationConfigRequest> = {
  encode(message: ListTaskPushNotificationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTaskPushNotificationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskPushNotificationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAgentCardRequest(): GetAgentCardRequest {
  return {};
}

export const GetAgentCardRequest: MessageFns<GetAgentCardRequest> = {
  encode(_: GetAgentCardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAgentCardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAgentCardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return { payload: undefined };
}

export const SendMessageResponse: MessageFns<SendMessageResponse> = {
  encode(message: SendMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "task":
        Task.encode(message.payload.value, writer.uint32(10).fork()).join();
        break;
      case "msg":
        Message.encode(message.payload.value, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = { $case: "task", value: Task.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = { $case: "msg", value: Message.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStreamResponse(): StreamResponse {
  return { payload: undefined };
}

export const StreamResponse: MessageFns<StreamResponse> = {
  encode(message: StreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "task":
        Task.encode(message.payload.value, writer.uint32(10).fork()).join();
        break;
      case "msg":
        Message.encode(message.payload.value, writer.uint32(18).fork()).join();
        break;
      case "statusUpdate":
        TaskStatusUpdateEvent.encode(message.payload.value, writer.uint32(26).fork()).join();
        break;
      case "artifactUpdate":
        TaskArtifactUpdateEvent.encode(message.payload.value, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = { $case: "task", value: Task.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = { $case: "msg", value: Message.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = { $case: "statusUpdate", value: TaskStatusUpdateEvent.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = { $case: "artifactUpdate", value: TaskArtifactUpdateEvent.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTaskPushNotificationConfigResponse(): ListTaskPushNotificationConfigResponse {
  return { configs: [], nextPageToken: "" };
}

export const ListTaskPushNotificationConfigResponse: MessageFns<ListTaskPushNotificationConfigResponse> = {
  encode(message: ListTaskPushNotificationConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      TaskPushNotificationConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTaskPushNotificationConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskPushNotificationConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(TaskPushNotificationConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/**
 * A2AService defines the gRPC version of the A2A protocol. This has a slightly
 * different shape than the JSONRPC version to better conform to AIP-127,
 * where appropriate. The nouns are AgentCard, Message, Task and
 * TaskPushNotificationConfig.
 * - Messages are not a standard resource so there is no get/delete/update/list
 *   interface, only a send and stream custom methods.
 * - Tasks have a get interface and custom cancel and subscribe methods.
 * - TaskPushNotificationConfig are a resource whose parent is a task.
 *   They have get, list and create methods.
 * - AgentCard is a static resource with only a get method.
 * fields are not present as they don't comply with AIP rules, and the
 * optional history_length on the get task method is not present as it also
 * violates AIP-127 and AIP-131.
 */
export type A2AServiceService = typeof A2AServiceService;
export const A2AServiceService = {
  /**
   * Send a message to the agent. This is a blocking call that will return the
   * task once it is completed, or a LRO if requested.
   */
  sendMessage: {
    path: "/a2a.v1.A2AService/SendMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) => Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: SendMessageResponse) => Buffer.from(SendMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessageResponse.decode(value),
  },
  /**
   * SendStreamingMessage is a streaming call that will return a stream of
   * task update events until the Task is in an interrupted or terminal state.
   */
  sendStreamingMessage: {
    path: "/a2a.v1.A2AService/SendStreamingMessage",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SendMessageRequest) => Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: StreamResponse) => Buffer.from(StreamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamResponse.decode(value),
  },
  /** Get the current state of a task from the agent. */
  getTask: {
    path: "/a2a.v1.A2AService/GetTask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTaskRequest) => Buffer.from(GetTaskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTaskRequest.decode(value),
    responseSerialize: (value: Task) => Buffer.from(Task.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Task.decode(value),
  },
  /**
   * Cancel a task from the agent. If supported one should expect no
   * more task updates for the task.
   */
  cancelTask: {
    path: "/a2a.v1.A2AService/CancelTask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelTaskRequest) => Buffer.from(CancelTaskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelTaskRequest.decode(value),
    responseSerialize: (value: Task) => Buffer.from(Task.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Task.decode(value),
  },
  /**
   * TaskSubscription is a streaming call that will return a stream of task
   * update events. This attaches the stream to an existing in process task.
   * If the task is complete the stream will return the completed task (like
   * GetTask) and close the stream.
   */
  taskSubscription: {
    path: "/a2a.v1.A2AService/TaskSubscription",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TaskSubscriptionRequest) => Buffer.from(TaskSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TaskSubscriptionRequest.decode(value),
    responseSerialize: (value: StreamResponse) => Buffer.from(StreamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamResponse.decode(value),
  },
  /** Set a push notification config for a task. */
  createTaskPushNotificationConfig: {
    path: "/a2a.v1.A2AService/CreateTaskPushNotificationConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTaskPushNotificationConfigRequest) =>
      Buffer.from(CreateTaskPushNotificationConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateTaskPushNotificationConfigRequest.decode(value),
    responseSerialize: (value: TaskPushNotificationConfig) =>
      Buffer.from(TaskPushNotificationConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TaskPushNotificationConfig.decode(value),
  },
  /** Get a push notification config for a task. */
  getTaskPushNotificationConfig: {
    path: "/a2a.v1.A2AService/GetTaskPushNotificationConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTaskPushNotificationConfigRequest) =>
      Buffer.from(GetTaskPushNotificationConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTaskPushNotificationConfigRequest.decode(value),
    responseSerialize: (value: TaskPushNotificationConfig) =>
      Buffer.from(TaskPushNotificationConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TaskPushNotificationConfig.decode(value),
  },
  /** Get a list of push notifications configured for a task. */
  listTaskPushNotificationConfig: {
    path: "/a2a.v1.A2AService/ListTaskPushNotificationConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTaskPushNotificationConfigRequest) =>
      Buffer.from(ListTaskPushNotificationConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListTaskPushNotificationConfigRequest.decode(value),
    responseSerialize: (value: ListTaskPushNotificationConfigResponse) =>
      Buffer.from(ListTaskPushNotificationConfigResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListTaskPushNotificationConfigResponse.decode(value),
  },
  /** GetAgentCard returns the agent card for the agent. */
  getAgentCard: {
    path: "/a2a.v1.A2AService/GetAgentCard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAgentCardRequest) => Buffer.from(GetAgentCardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAgentCardRequest.decode(value),
    responseSerialize: (value: AgentCard) => Buffer.from(AgentCard.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AgentCard.decode(value),
  },
  /** Delete a push notification config for a task. */
  deleteTaskPushNotificationConfig: {
    path: "/a2a.v1.A2AService/DeleteTaskPushNotificationConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteTaskPushNotificationConfigRequest) =>
      Buffer.from(DeleteTaskPushNotificationConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteTaskPushNotificationConfigRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
} as const;

export interface A2AServiceServer extends UntypedServiceImplementation {
  /**
   * Send a message to the agent. This is a blocking call that will return the
   * task once it is completed, or a LRO if requested.
   */
  sendMessage: handleUnaryCall<SendMessageRequest, SendMessageResponse>;
  /**
   * SendStreamingMessage is a streaming call that will return a stream of
   * task update events until the Task is in an interrupted or terminal state.
   */
  sendStreamingMessage: handleServerStreamingCall<SendMessageRequest, StreamResponse>;
  /** Get the current state of a task from the agent. */
  getTask: handleUnaryCall<GetTaskRequest, Task>;
  /**
   * Cancel a task from the agent. If supported one should expect no
   * more task updates for the task.
   */
  cancelTask: handleUnaryCall<CancelTaskRequest, Task>;
  /**
   * TaskSubscription is a streaming call that will return a stream of task
   * update events. This attaches the stream to an existing in process task.
   * If the task is complete the stream will return the completed task (like
   * GetTask) and close the stream.
   */
  taskSubscription: handleServerStreamingCall<TaskSubscriptionRequest, StreamResponse>;
  /** Set a push notification config for a task. */
  createTaskPushNotificationConfig: handleUnaryCall<
    CreateTaskPushNotificationConfigRequest,
    TaskPushNotificationConfig
  >;
  /** Get a push notification config for a task. */
  getTaskPushNotificationConfig: handleUnaryCall<GetTaskPushNotificationConfigRequest, TaskPushNotificationConfig>;
  /** Get a list of push notifications configured for a task. */
  listTaskPushNotificationConfig: handleUnaryCall<
    ListTaskPushNotificationConfigRequest,
    ListTaskPushNotificationConfigResponse
  >;
  /** GetAgentCard returns the agent card for the agent. */
  getAgentCard: handleUnaryCall<GetAgentCardRequest, AgentCard>;
  /** Delete a push notification config for a task. */
  deleteTaskPushNotificationConfig: handleUnaryCall<DeleteTaskPushNotificationConfigRequest, Empty>;
}

export interface A2AServiceClient extends Client {
  /**
   * Send a message to the agent. This is a blocking call that will return the
   * task once it is completed, or a LRO if requested.
   */
  sendMessage(
    request: SendMessageRequest,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  /**
   * SendStreamingMessage is a streaming call that will return a stream of
   * task update events until the Task is in an interrupted or terminal state.
   */
  sendStreamingMessage(
    request: SendMessageRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamResponse>;
  sendStreamingMessage(
    request: SendMessageRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamResponse>;
  /** Get the current state of a task from the agent. */
  getTask(request: GetTaskRequest, callback: (error: ServiceError | null, response: Task) => void): ClientUnaryCall;
  getTask(
    request: GetTaskRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Task) => void,
  ): ClientUnaryCall;
  getTask(
    request: GetTaskRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Task) => void,
  ): ClientUnaryCall;
  /**
   * Cancel a task from the agent. If supported one should expect no
   * more task updates for the task.
   */
  cancelTask(
    request: CancelTaskRequest,
    callback: (error: ServiceError | null, response: Task) => void,
  ): ClientUnaryCall;
  cancelTask(
    request: CancelTaskRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Task) => void,
  ): ClientUnaryCall;
  cancelTask(
    request: CancelTaskRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Task) => void,
  ): ClientUnaryCall;
  /**
   * TaskSubscription is a streaming call that will return a stream of task
   * update events. This attaches the stream to an existing in process task.
   * If the task is complete the stream will return the completed task (like
   * GetTask) and close the stream.
   */
  taskSubscription(
    request: TaskSubscriptionRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamResponse>;
  taskSubscription(
    request: TaskSubscriptionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamResponse>;
  /** Set a push notification config for a task. */
  createTaskPushNotificationConfig(
    request: CreateTaskPushNotificationConfigRequest,
    callback: (error: ServiceError | null, response: TaskPushNotificationConfig) => void,
  ): ClientUnaryCall;
  createTaskPushNotificationConfig(
    request: CreateTaskPushNotificationConfigRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TaskPushNotificationConfig) => void,
  ): ClientUnaryCall;
  createTaskPushNotificationConfig(
    request: CreateTaskPushNotificationConfigRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TaskPushNotificationConfig) => void,
  ): ClientUnaryCall;
  /** Get a push notification config for a task. */
  getTaskPushNotificationConfig(
    request: GetTaskPushNotificationConfigRequest,
    callback: (error: ServiceError | null, response: TaskPushNotificationConfig) => void,
  ): ClientUnaryCall;
  getTaskPushNotificationConfig(
    request: GetTaskPushNotificationConfigRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TaskPushNotificationConfig) => void,
  ): ClientUnaryCall;
  getTaskPushNotificationConfig(
    request: GetTaskPushNotificationConfigRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TaskPushNotificationConfig) => void,
  ): ClientUnaryCall;
  /** Get a list of push notifications configured for a task. */
  listTaskPushNotificationConfig(
    request: ListTaskPushNotificationConfigRequest,
    callback: (error: ServiceError | null, response: ListTaskPushNotificationConfigResponse) => void,
  ): ClientUnaryCall;
  listTaskPushNotificationConfig(
    request: ListTaskPushNotificationConfigRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListTaskPushNotificationConfigResponse) => void,
  ): ClientUnaryCall;
  listTaskPushNotificationConfig(
    request: ListTaskPushNotificationConfigRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListTaskPushNotificationConfigResponse) => void,
  ): ClientUnaryCall;
  /** GetAgentCard returns the agent card for the agent. */
  getAgentCard(
    request: GetAgentCardRequest,
    callback: (error: ServiceError | null, response: AgentCard) => void,
  ): ClientUnaryCall;
  getAgentCard(
    request: GetAgentCardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AgentCard) => void,
  ): ClientUnaryCall;
  getAgentCard(
    request: GetAgentCardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AgentCard) => void,
  ): ClientUnaryCall;
  /** Delete a push notification config for a task. */
  deleteTaskPushNotificationConfig(
    request: DeleteTaskPushNotificationConfigRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteTaskPushNotificationConfig(
    request: DeleteTaskPushNotificationConfigRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteTaskPushNotificationConfig(
    request: DeleteTaskPushNotificationConfigRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const A2AServiceClient = makeGenericClientConstructor(A2AServiceService, "a2a.v1.A2AService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): A2AServiceClient;
  service: typeof A2AServiceService;
  serviceName: string;
};

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
