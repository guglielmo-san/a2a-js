// @generated by protobuf-ts 2.11.1 with parameter server_grpc1,client_grpc1
// @generated from protobuf file "a2a.proto" (package "a2a.v1", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
import { Struct } from "./google/protobuf/struct";
// /////// Data Model ////////////

/**
 * Configuration of a send message request.
 *
 * @generated from protobuf message a2a.v1.SendMessageConfiguration
 */
export interface SendMessageConfiguration {
    /**
     * A list of media types the client is prepared to accept for response parts. Agents SHOULD use this to tailor their output.
     *
     * @generated from protobuf field: repeated string accepted_output_modes = 1
     */
    acceptedOutputModes: string[];
    /**
     * Configuration for the agent to send push notifications for task updates.
     *
     * @generated from protobuf field: a2a.v1.PushNotificationConfig push_notification_config = 2
     */
    pushNotificationConfig?: PushNotificationConfig;
    /**
     * The maximum number of messages to include in the history.
     *
     * @generated from protobuf field: optional int32 history_length = 3
     */
    historyLength?: number;
    /**
     * If true, the operation waits until the task reaches a terminal state before returning. Default is false.
     *
     * @generated from protobuf field: bool blocking = 4
     */
    blocking: boolean;
}
/**
 * Task is the core unit of action for A2A. It has a current status
 * and when results are created for the task they are stored in the
 * artifact. If there are multiple turns for a task, these are stored in
 * history.
 *
 * @generated from protobuf message a2a.v1.Task
 */
export interface Task {
    /**
     * Unique identifier (e.g. UUID) for the task, generated by the server for a
     * new task.
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Unique identifier (e.g. UUID) for the contextual collection of interactions
     * (tasks and messages). Created by the A2A server.
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The current status of a Task, including state and a message.
     *
     * @generated from protobuf field: a2a.v1.TaskStatus status = 3
     */
    status?: TaskStatus;
    /**
     * A set of output artifacts for a Task.
     *
     * @generated from protobuf field: repeated a2a.v1.Artifact artifacts = 4
     */
    artifacts: Artifact[];
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * The history of interactions from a task.
     *
     * @generated from protobuf field: repeated a2a.v1.Message history = 5
     */
    history: Message[];
    /**
     * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
     * A key/value object to store custom metadata about a task.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
}
/**
 * A container for the status of a task
 *
 * @generated from protobuf message a2a.v1.TaskStatus
 */
export interface TaskStatus {
    /**
     * The current state of this task.
     *
     * @generated from protobuf field: a2a.v1.TaskState state = 1
     */
    state: TaskState;
    /**
     * A message associated with the status.
     *
     * @generated from protobuf field: a2a.v1.Message message = 2
     */
    message?: Message;
    /**
     * ISO 8601 Timestamp when the status was recorded.
     * Example: "2023-10-27T10:00:00Z"
     *
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
     */
    timestamp?: Timestamp;
}
/**
 * Part represents a container for a section of communication content.
 * Parts can be purely textual, some sort of file (image, video, etc) or
 * a structured data blob (i.e. JSON).
 *
 * @generated from protobuf message a2a.v1.Part
 */
export interface Part {
    /**
     * @generated from protobuf oneof: part
     */
    part: {
        oneofKind: "text";
        /**
         * The string content of the text part.
         *
         * @generated from protobuf field: string text = 1
         */
        text: string;
    } | {
        oneofKind: "file";
        /**
         * The file content, represented as either a URI or as base64-encoded bytes.
         *
         * @generated from protobuf field: a2a.v1.FilePart file = 2
         */
        file: FilePart;
    } | {
        oneofKind: "data";
        /**
         * The structured data content.
         *
         * @generated from protobuf field: a2a.v1.DataPart data = 3
         */
        data: DataPart;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional metadata associated with this part.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 4
     */
    metadata?: Struct;
}
/**
 * FilePart represents the different ways files can be provided. If files are
 * small, directly feeding the bytes is supported via file_with_bytes. If the
 * file is large, the agent should read the content as appropriate directly
 * from the file_with_uri source.
 *
 * @generated from protobuf message a2a.v1.FilePart
 */
export interface FilePart {
    /**
     * @generated from protobuf oneof: file
     */
    file: {
        oneofKind: "fileWithUri";
        /**
         * A URL pointing to the file's content.
         *
         * @generated from protobuf field: string file_with_uri = 1
         */
        fileWithUri: string;
    } | {
        oneofKind: "fileWithBytes";
        /**
         * The base64-encoded content of the file.
         *
         * @generated from protobuf field: bytes file_with_bytes = 2
         */
        fileWithBytes: Uint8Array;
    } | {
        oneofKind: undefined;
    };
    /**
     * The media type of the file (e.g., "application/pdf").
     *
     * @generated from protobuf field: string media_type = 3
     */
    mediaType: string;
    /**
     * An optional name for the file (e.g., "document.pdf").
     *
     * @generated from protobuf field: string name = 4
     */
    name: string;
}
/**
 * DataPart represents a structured blob.
 *
 * @generated from protobuf message a2a.v1.DataPart
 */
export interface DataPart {
    /**
     *  A JSON object containing arbitrary data.
     *
     * @generated from protobuf field: google.protobuf.Struct data = 1
     */
    data?: Struct;
}
/**
 * Message is one unit of communication between client and server. It is
 * associated with a context and optionally a task. Since the server is
 * responsible for the context definition, it must always provide a context_id
 * in its messages. The client can optionally provide the context_id if it
 * knows the context to associate the message to. Similarly for task_id,
 * except the server decides if a task is created and whether to include the
 * task_id.
 *
 * @generated from protobuf message a2a.v1.Message
 */
export interface Message {
    /**
     * The unique identifier (e.g. UUID) of the message. This is required and
     * created by the message creator.
     *
     * @generated from protobuf field: string message_id = 1
     */
    messageId: string;
    /**
     * The context id of the message. This is optional and if set, the message
     * will be associated with the given context.
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The task id of the message. This is optional and if set, the message
     * will be associated with the given task.
     *
     * @generated from protobuf field: string task_id = 3
     */
    taskId: string;
    /**
     * Identifies the sender of the message.
     *
     * @generated from protobuf field: a2a.v1.Role role = 4
     */
    role: Role;
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * Parts is the container of the message content.
     *
     * @generated from protobuf field: repeated a2a.v1.Part parts = 5
     */
    parts: Part[];
    /**
     * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
     * Any optional metadata to provide along with the message.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
    /**
     * The URIs of extensions that are present or contributed to this Message.
     *
     * @generated from protobuf field: repeated string extensions = 7
     */
    extensions: string[];
    /**
     * A list of task IDs that this message references for additional context.
     *
     * @generated from protobuf field: repeated string reference_task_ids = 8
     */
    referenceTaskIds: string[];
}
/**
 * Artifacts represent task outputs.
 *
 * @generated from protobuf message a2a.v1.Artifact
 */
export interface Artifact {
    /**
     * Unique identifier (e.g. UUID) for the artifact. It must be at least unique
     * within a task.
     *
     * @generated from protobuf field: string artifact_id = 1
     */
    artifactId: string;
    /**
     * A human readable name for the artifact.
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * A human readable description of the artifact, optional.
     *
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * The content of the artifact. Must contain at least one part.
     *
     * @generated from protobuf field: repeated a2a.v1.Part parts = 5
     */
    parts: Part[];
    /**
     * Optional metadata included with the artifact.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
    /**
     * The URIs of extensions that are present or contributed to this Artifact.
     *
     * @generated from protobuf field: repeated string extensions = 7
     */
    extensions: string[];
}
/**
 * An event sent by the agent to notify the client of a change in a task's
 * status.
 *
 * @generated from protobuf message a2a.v1.TaskStatusUpdateEvent
 */
export interface TaskStatusUpdateEvent {
    /**
     * The id of the task that is changed
     *
     * @generated from protobuf field: string task_id = 1
     */
    taskId: string;
    /**
     * The id of the context that the task belongs to
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The new status of the task.
     *
     * @generated from protobuf field: a2a.v1.TaskStatus status = 3
     */
    status?: TaskStatus;
    /**
     * If true, this is the final event in the stream for this interaction.
     *
     * @generated from protobuf field: bool final = 4
     */
    final: boolean;
    /**
     * Optional metadata to associate with the task update.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 5
     */
    metadata?: Struct;
}
/**
 * TaskArtifactUpdateEvent represents a task delta where an artifact has
 * been generated.
 *
 * @generated from protobuf message a2a.v1.TaskArtifactUpdateEvent
 */
export interface TaskArtifactUpdateEvent {
    /**
     * The id of the task for this artifact.
     *
     * @generated from protobuf field: string task_id = 1
     */
    taskId: string;
    /**
     * The id of the context that this task belongs to.
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The artifact that was generated or updated.
     *
     * @generated from protobuf field: a2a.v1.Artifact artifact = 3
     */
    artifact?: Artifact;
    /**
     * If true, the content of this artifact should be appended to a previously
     * sent artifact with the same ID.
     *
     * @generated from protobuf field: bool append = 4
     */
    append: boolean;
    /**
     * If true, this is the final chunk of the artifact.
     *
     * @generated from protobuf field: bool last_chunk = 5
     */
    lastChunk: boolean;
    /**
     * Optional metadata associated with the artifact update.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
}
/**
 * Configuration for setting up push notifications for task updates.
 *
 * @generated from protobuf message a2a.v1.PushNotificationConfig
 */
export interface PushNotificationConfig {
    /**
     * A unique identifier (e.g. UUID) for this push notification.
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Url to send the notification too
     *
     * @generated from protobuf field: string url = 2
     */
    url: string;
    /**
     * Token unique for this task/session
     *
     * @generated from protobuf field: string token = 3
     */
    token: string;
    /**
     * Information about the authentication to sent with the notification
     *
     * @generated from protobuf field: a2a.v1.AuthenticationInfo authentication = 4
     */
    authentication?: AuthenticationInfo;
}
/**
 * Defines authentication details, used for push notifications.
 *
 * @generated from protobuf message a2a.v1.AuthenticationInfo
 */
export interface AuthenticationInfo {
    /**
     * A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
     *
     * @generated from protobuf field: repeated string schemes = 1
     */
    schemes: string[];
    /**
     * Optional credentials
     *
     * @generated from protobuf field: string credentials = 2
     */
    credentials: string;
}
/**
 * Declares a combination of a target URL and a transport protocol for interacting with the agent.
 * This allows agents to expose the same functionality over multiple protocol binding mechanisms.
 *
 * @generated from protobuf message a2a.v1.AgentInterface
 */
export interface AgentInterface {
    /**
     * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
     * Example: "https://api.example.com/a2a/v1", "https://grpc.example.com/a2a"
     *
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * The protocol binding supported at this URL. This is an open form string, to be
     * easily extended for other protocol bindings. The core ones officially
     * supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.
     *
     * @generated from protobuf field: string protocol_binding = 2
     */
    protocolBinding: string;
    /**
     * Tenant to be set in the request when calling the agent.
     *
     * @generated from protobuf field: string tenant = 3
     */
    tenant: string;
}
/**
 * AgentCard is a self-describing manifest for an agent. It provides essential
 * metadata including the agent's identity, capabilities, skills, supported
 * communication methods, and security requirements.
 * Next ID: 20
 *
 * @generated from protobuf message a2a.v1.AgentCard
 */
export interface AgentCard {
    /**
     * The version of the A2A protocol this agent supports.
     * Default: "1.0"
     *
     * @generated from protobuf field: optional string protocol_version = 16
     */
    protocolVersion?: string;
    /**
     * A human readable name for the agent.
     * Example: "Recipe Agent"
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * A human-readable description of the agent, assisting users and other agents
     * in understanding its purpose.
     * Example: "Agent that helps users with recipes and cooking."
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Ordered list of supported interfaces. First entry is preferred.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentInterface supported_interfaces = 19
     */
    supportedInterfaces: AgentInterface[];
    /**
     * DEPRECATED: Use 'supported_interfaces' instead.
     *
     * @deprecated
     * @generated from protobuf field: optional string url = 3 [deprecated = true]
     */
    url?: string;
    /**
     * DEPRECATED: Use 'supported_interfaces' instead.
     *
     * @deprecated
     * @generated from protobuf field: optional string preferred_transport = 14 [deprecated = true]
     */
    preferredTransport?: string;
    /**
     * DEPRECATED: Use 'supported_interfaces' instead.
     *
     * @deprecated
     * @generated from protobuf field: repeated a2a.v1.AgentInterface additional_interfaces = 15 [deprecated = true]
     */
    additionalInterfaces: AgentInterface[];
    /**
     * The service provider of the agent.
     *
     * @generated from protobuf field: a2a.v1.AgentProvider provider = 4
     */
    provider?: AgentProvider;
    /**
     * The version of the agent.
     * Example: "1.0.0"
     *
     * @generated from protobuf field: string version = 5
     */
    version: string;
    /**
     * A url to provide additional documentation about the agent.
     *
     * @generated from protobuf field: optional string documentation_url = 6
     */
    documentationUrl?: string;
    /**
     * A2A Capability set supported by the agent.
     *
     * @generated from protobuf field: a2a.v1.AgentCapabilities capabilities = 7
     */
    capabilities?: AgentCapabilities;
    /**
     * The security scheme details used for authenticating with this agent.
     *
     * @generated from protobuf field: map<string, a2a.v1.SecurityScheme> security_schemes = 8
     */
    securitySchemes: {
        [key: string]: SecurityScheme;
    };
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * Security requirements for contacting the agent.
     *
     * @generated from protobuf field: repeated a2a.v1.Security security = 9
     */
    security: Security[];
    /**
     * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
     * The set of interaction modes that the agent supports across all skills.
     * This can be overridden per skill. Defined as media types.
     *
     * @generated from protobuf field: repeated string default_input_modes = 10
     */
    defaultInputModes: string[];
    /**
     * The media types supported as outputs from this agent.
     *
     * @generated from protobuf field: repeated string default_output_modes = 11
     */
    defaultOutputModes: string[];
    /**
     * Skills represent an ability of an agent. It is largely
     * a descriptive concept but represents a more focused set of behaviors that the
     * agent is likely to succeed at.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentSkill skills = 12
     */
    skills: AgentSkill[];
    /**
     * Whether the agent supports providing an extended agent card when authenticated.
     *
     * @generated from protobuf field: optional bool supports_extended_agent_card = 13
     */
    supportsExtendedAgentCard?: boolean;
    /**
     * JSON Web Signatures computed for this AgentCard.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentCardSignature signatures = 17
     */
    signatures: AgentCardSignature[];
    /**
     * An optional URL to an icon for the agent.
     *
     * @generated from protobuf field: optional string icon_url = 18
     */
    iconUrl?: string;
}
/**
 * Represents the service provider of an agent.
 *
 * @generated from protobuf message a2a.v1.AgentProvider
 */
export interface AgentProvider {
    /**
     * A URL for the agent provider's website or relevant documentation.
     * Example: "https://ai.google.dev"
     *
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * The name of the agent provider's organization.
     * Example: "Google"
     *
     * @generated from protobuf field: string organization = 2
     */
    organization: string;
}
/**
 * Defines optional capabilities supported by an agent.
 *
 * @generated from protobuf message a2a.v1.AgentCapabilities
 */
export interface AgentCapabilities {
    /**
     * Indicates if the agent supports streaming responses.
     *
     * @generated from protobuf field: optional bool streaming = 1
     */
    streaming?: boolean;
    /**
     * Indicates if the agent supports sending push notifications for asynchronous task updates.
     *
     * @generated from protobuf field: optional bool push_notifications = 2
     */
    pushNotifications?: boolean;
    /**
     * A list of protocol extensions supported by the agent.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentExtension extensions = 3
     */
    extensions: AgentExtension[];
    /**
     * Indicates if the agent provides a history of state transitions for a task.
     *
     * @generated from protobuf field: optional bool state_transition_history = 4
     */
    stateTransitionHistory?: boolean;
}
/**
 * A declaration of a protocol extension supported by an Agent.
 *
 * @generated from protobuf message a2a.v1.AgentExtension
 */
export interface AgentExtension {
    /**
     * The unique URI identifying the extension.
     *
     * @generated from protobuf field: string uri = 1
     */
    uri: string;
    /**
     * A human-readable description of how this agent uses the extension.
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * If true, the client must understand and comply with the extension's requirements.
     *
     * @generated from protobuf field: bool required = 3
     */
    required: boolean;
    /**
     * Optional, extension-specific configuration parameters.
     *
     * @generated from protobuf field: google.protobuf.Struct params = 4
     */
    params?: Struct;
}
/**
 * Represents a distinct capability or function that an agent can perform.
 *
 * @generated from protobuf message a2a.v1.AgentSkill
 */
export interface AgentSkill {
    /**
     * A unique identifier for the agent's skill.
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * A human-readable name for the skill.
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * A detailed description of the skill.
     *
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * A set of keywords describing the skill's capabilities.
     *
     * @generated from protobuf field: repeated string tags = 4
     */
    tags: string[];
    /**
     * Example prompts or scenarios that this skill can handle.
     *
     * @generated from protobuf field: repeated string examples = 5
     */
    examples: string[];
    /**
     * The set of supported input media types for this skill, overriding the agent's defaults.
     *
     * @generated from protobuf field: repeated string input_modes = 6
     */
    inputModes: string[];
    /**
     * The set of supported output media types for this skill, overriding the agent's defaults.
     *
     * @generated from protobuf field: repeated string output_modes = 7
     */
    outputModes: string[];
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * Security schemes necessary for this skill.
     *
     * @generated from protobuf field: repeated a2a.v1.Security security = 8
     */
    security: Security[]; // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
}
/**
 * AgentCardSignature represents a JWS signature of an AgentCard.
 * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
 *
 * @generated from protobuf message a2a.v1.AgentCardSignature
 */
export interface AgentCardSignature {
    /**
     * The protected JWS header for the signature. This is always a
     * base64url-encoded JSON object. Required.
     *
     * @generated from protobuf field: string protected = 1
     */
    protected: string;
    /**
     * The computed signature, base64url-encoded. Required.
     *
     * @generated from protobuf field: string signature = 2
     */
    signature: string;
    /**
     * The unprotected JWS header values.
     *
     * @generated from protobuf field: google.protobuf.Struct header = 3
     */
    header?: Struct;
}
/**
 * A container associating a push notification configuration with a specific
 * task.
 *
 * @generated from protobuf message a2a.v1.TaskPushNotificationConfig
 */
export interface TaskPushNotificationConfig {
    /**
     * The resource name of the config.
     * Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * The push notification configuration details.
     *
     * @generated from protobuf field: a2a.v1.PushNotificationConfig push_notification_config = 2
     */
    pushNotificationConfig?: PushNotificationConfig;
}
/**
 * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
 *
 * @generated from protobuf message a2a.v1.StringList
 */
export interface StringList {
    /**
     * @generated from protobuf field: repeated string list = 1
     */
    list: string[];
}
/**
 * @generated from protobuf message a2a.v1.Security
 */
export interface Security {
    /**
     * @generated from protobuf field: map<string, a2a.v1.StringList> schemes = 1
     */
    schemes: {
        [key: string]: StringList;
    };
}
/**
 * Defines a security scheme that can be used to secure an agent's endpoints.
 * This is a discriminated union type based on the OpenAPI 3.2 Security Scheme Object.
 * See: https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object
 *
 * @generated from protobuf message a2a.v1.SecurityScheme
 */
export interface SecurityScheme {
    /**
     * @generated from protobuf oneof: scheme
     */
    scheme: {
        oneofKind: "apiKeySecurityScheme";
        /**
         * API key-based authentication.
         *
         * @generated from protobuf field: a2a.v1.APIKeySecurityScheme api_key_security_scheme = 1
         */
        apiKeySecurityScheme: APIKeySecurityScheme;
    } | {
        oneofKind: "httpAuthSecurityScheme";
        /**
         * HTTP authentication (Basic, Bearer, etc.).
         *
         * @generated from protobuf field: a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme = 2
         */
        httpAuthSecurityScheme: HTTPAuthSecurityScheme;
    } | {
        oneofKind: "oauth2SecurityScheme";
        /**
         * OAuth 2.0 authentication.
         *
         * @generated from protobuf field: a2a.v1.OAuth2SecurityScheme oauth2_security_scheme = 3
         */
        oauth2SecurityScheme: OAuth2SecurityScheme;
    } | {
        oneofKind: "openIdConnectSecurityScheme";
        /**
         * OpenID Connect authentication.
         *
         * @generated from protobuf field: a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4
         */
        openIdConnectSecurityScheme: OpenIdConnectSecurityScheme;
    } | {
        oneofKind: "mtlsSecurityScheme";
        /**
         * Mutual TLS authentication.
         *
         * @generated from protobuf field: a2a.v1.MutualTlsSecurityScheme mtls_security_scheme = 5
         */
        mtlsSecurityScheme: MutualTlsSecurityScheme;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Defines a security scheme using an API key.
 *
 * @generated from protobuf message a2a.v1.APIKeySecurityScheme
 */
export interface APIKeySecurityScheme {
    /**
     * An optional description for the security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * The location of the API key. Valid values are "query", "header", or "cookie".
     *
     * @generated from protobuf field: string location = 2
     */
    location: string;
    /**
     * The name of the header, query, or cookie parameter to be used.
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
}
/**
 * Defines a security scheme using HTTP authentication.
 *
 * @generated from protobuf message a2a.v1.HTTPAuthSecurityScheme
 */
export interface HTTPAuthSecurityScheme {
    /**
     * An optional description for the security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * The name of the HTTP Authentication scheme to be used in the Authorization header,
     * as defined in RFC7235 (e.g., "Bearer").
     * This value should be registered in the IANA Authentication Scheme registry.
     *
     * @generated from protobuf field: string scheme = 2
     */
    scheme: string;
    /**
     * A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
     * This is primarily for documentation purposes.
     *
     * @generated from protobuf field: string bearer_format = 3
     */
    bearerFormat: string;
}
/**
 * Defines a security scheme using OAuth 2.0.
 *
 * @generated from protobuf message a2a.v1.OAuth2SecurityScheme
 */
export interface OAuth2SecurityScheme {
    /**
     * An optional description for the security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * An object containing configuration information for the supported OAuth 2.0 flows.
     *
     * @generated from protobuf field: a2a.v1.OAuthFlows flows = 2
     */
    flows?: OAuthFlows;
    /**
     * URL to the oauth2 authorization server metadata
     * RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
     *
     * @generated from protobuf field: string oauth2_metadata_url = 3
     */
    oauth2MetadataUrl: string;
}
/**
 * Defines a security scheme using OpenID Connect.
 *
 * @generated from protobuf message a2a.v1.OpenIdConnectSecurityScheme
 */
export interface OpenIdConnectSecurityScheme {
    /**
     * An optional description for the security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * The OpenID Connect Discovery URL for the OIDC provider's metadata.
     * See: https://openid.net/specs/openid-connect-discovery-1_0.html
     *
     * @generated from protobuf field: string open_id_connect_url = 2
     */
    openIdConnectUrl: string;
}
/**
 * Defines a security scheme using mTLS authentication.
 *
 * @generated from protobuf message a2a.v1.MutualTlsSecurityScheme
 */
export interface MutualTlsSecurityScheme {
    /**
     * An optional description for the security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
}
/**
 * Defines the configuration for the supported OAuth 2.0 flows.
 *
 * @generated from protobuf message a2a.v1.OAuthFlows
 */
export interface OAuthFlows {
    /**
     * @generated from protobuf oneof: flow
     */
    flow: {
        oneofKind: "authorizationCode";
        /**
         * Configuration for the OAuth Authorization Code flow.
         *
         * @generated from protobuf field: a2a.v1.AuthorizationCodeOAuthFlow authorization_code = 1
         */
        authorizationCode: AuthorizationCodeOAuthFlow;
    } | {
        oneofKind: "clientCredentials";
        /**
         * Configuration for the OAuth Client Credentials flow.
         *
         * @generated from protobuf field: a2a.v1.ClientCredentialsOAuthFlow client_credentials = 2
         */
        clientCredentials: ClientCredentialsOAuthFlow;
    } | {
        oneofKind: "implicit";
        /**
         * Configuration for the OAuth Implicit flow.
         *
         * @generated from protobuf field: a2a.v1.ImplicitOAuthFlow implicit = 3
         */
        implicit: ImplicitOAuthFlow;
    } | {
        oneofKind: "password";
        /**
         * Configuration for the OAuth Resource Owner Password flow.
         *
         * @generated from protobuf field: a2a.v1.PasswordOAuthFlow password = 4
         */
        password: PasswordOAuthFlow;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Defines configuration details for the OAuth 2.0 Authorization Code flow.
 *
 * @generated from protobuf message a2a.v1.AuthorizationCodeOAuthFlow
 */
export interface AuthorizationCodeOAuthFlow {
    /**
     * The authorization URL to be used for this flow.
     *
     * @generated from protobuf field: string authorization_url = 1
     */
    authorizationUrl: string;
    /**
     * The token URL to be used for this flow.
     *
     * @generated from protobuf field: string token_url = 2
     */
    tokenUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens.
     *
     * @generated from protobuf field: string refresh_url = 3
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme.
     *
     * @generated from protobuf field: map<string, string> scopes = 4
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * Defines configuration details for the OAuth 2.0 Client Credentials flow.
 *
 * @generated from protobuf message a2a.v1.ClientCredentialsOAuthFlow
 */
export interface ClientCredentialsOAuthFlow {
    /**
     * The token URL to be used for this flow.
     *
     * @generated from protobuf field: string token_url = 1
     */
    tokenUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens.
     *
     * @generated from protobuf field: string refresh_url = 2
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme.
     *
     * @generated from protobuf field: map<string, string> scopes = 3
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * Defines configuration details for the OAuth 2.0 Implicit flow.
 *
 * @generated from protobuf message a2a.v1.ImplicitOAuthFlow
 */
export interface ImplicitOAuthFlow {
    /**
     * The authorization URL to be used for this flow.
     *
     * @generated from protobuf field: string authorization_url = 1
     */
    authorizationUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens.
     *
     * @generated from protobuf field: string refresh_url = 2
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme.
     *
     * @generated from protobuf field: map<string, string> scopes = 3
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
 *
 * @generated from protobuf message a2a.v1.PasswordOAuthFlow
 */
export interface PasswordOAuthFlow {
    /**
     * The token URL to be used for this flow.
     *
     * @generated from protobuf field: string token_url = 1
     */
    tokenUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens.
     *
     * @generated from protobuf field: string refresh_url = 2
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme.
     *
     * @generated from protobuf field: map<string, string> scopes = 3
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * /////////// Request Messages ///////////
 * Represents a request for the `message/send` method.
 *
 * @generated from protobuf message a2a.v1.SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 4
     */
    tenant: string;
    /**
     * The message to send to the agent.
     *
     * @generated from protobuf field: a2a.v1.Message request = 1 [json_name = "message"]
     */
    request?: Message;
    /**
     * Configuration for the send request.
     *
     * @generated from protobuf field: a2a.v1.SendMessageConfiguration configuration = 2
     */
    configuration?: SendMessageConfiguration;
    /**
     * A flexible key-value map for passing additional context or parameters.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 3
     */
    metadata?: Struct;
}
/**
 * Represents a request for the `tasks/get` method.
 *
 * @generated from protobuf message a2a.v1.GetTaskRequest
 */
export interface GetTaskRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 3
     */
    tenant: string;
    /**
     * The resource name of the task.
     * Format: tasks/{task_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * The maximum number of messages to include in the history.
     *
     * @generated from protobuf field: optional int32 history_length = 2
     */
    historyLength?: number;
}
/**
 * Parameters for listing tasks with optional filtering criteria.
 *
 * @generated from protobuf message a2a.v1.ListTasksRequest
 */
export interface ListTasksRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 9
     */
    tenant: string;
    /**
     * Filter tasks by context ID to get tasks from a specific conversation or session.
     *
     * @generated from protobuf field: string context_id = 1
     */
    contextId: string;
    /**
     * Filter tasks by their current status state.
     *
     * @generated from protobuf field: a2a.v1.TaskState status = 2
     */
    status: TaskState;
    /**
     * Maximum number of tasks to return. Must be between 1 and 100.
     * Defaults to 50 if not specified.
     *
     * @generated from protobuf field: optional int32 page_size = 3
     */
    pageSize?: number;
    /**
     * Token for pagination. Use the next_page_token from a previous ListTasksResponse.
     *
     * @generated from protobuf field: string page_token = 4
     */
    pageToken: string;
    /**
     * The maximum number of messages to include in each task's history.
     *
     * @generated from protobuf field: optional int32 history_length = 5
     */
    historyLength?: number;
    /**
     * Filter tasks updated after this timestamp (milliseconds since epoch).
     * Only tasks with a last updated time greater than or equal to this value will be returned.
     *
     * @generated from protobuf field: int64 last_updated_after = 6
     */
    lastUpdatedAfter: bigint;
    /**
     * Whether to include artifacts in the returned tasks.
     * Defaults to false to reduce payload size.
     *
     * @generated from protobuf field: optional bool include_artifacts = 7
     */
    includeArtifacts?: boolean;
}
/**
 * Result object for tasks/list method containing an array of tasks and pagination information.
 *
 * @generated from protobuf message a2a.v1.ListTasksResponse
 */
export interface ListTasksResponse {
    /**
     * Array of tasks matching the specified criteria.
     *
     * @generated from protobuf field: repeated a2a.v1.Task tasks = 1
     */
    tasks: Task[];
    /**
     * Token for retrieving the next page. Empty string if no more results.
     *
     * @generated from protobuf field: string next_page_token = 2
     */
    nextPageToken: string;
    /**
     * The size of page requested.
     *
     * @generated from protobuf field: int32 page_size = 3
     */
    pageSize: number;
    /**
     * Total number of tasks available (before pagination).
     *
     * @generated from protobuf field: int32 total_size = 4
     */
    totalSize: number;
}
/**
 * Represents a request for the `tasks/cancel` method.
 *
 * @generated from protobuf message a2a.v1.CancelTaskRequest
 */
export interface CancelTaskRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 2
     */
    tenant: string;
    /**
     * The resource name of the task to cancel.
     * Format: tasks/{task_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.GetTaskPushNotificationConfigRequest
 */
export interface GetTaskPushNotificationConfigRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 2
     */
    tenant: string;
    /**
     * The resource name of the config to retrieve.
     * Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * Represents a request for the `tasks/pushNotificationConfig/delete` method.
 *
 * @generated from protobuf message a2a.v1.DeleteTaskPushNotificationConfigRequest
 */
export interface DeleteTaskPushNotificationConfigRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 2
     */
    tenant: string;
    /**
     * The resource name of the config to delete.
     * Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * Represents a request for the `tasks/pushNotificationConfig/set` method.
 *
 * @generated from protobuf message a2a.v1.SetTaskPushNotificationConfigRequest
 */
export interface SetTaskPushNotificationConfigRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 4
     */
    tenant: string;
    /**
     * The parent task resource for this config.
     * Format: tasks/{task_id}
     *
     * @generated from protobuf field: string parent = 1
     */
    parent: string;
    /**
     * The ID for the new config.
     *
     * @generated from protobuf field: string config_id = 2
     */
    configId: string;
    /**
     * The configuration to create.
     *
     * @generated from protobuf field: a2a.v1.TaskPushNotificationConfig config = 3
     */
    config?: TaskPushNotificationConfig;
}
/**
 * @generated from protobuf message a2a.v1.SubscribeToTaskRequest
 */
export interface SubscribeToTaskRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 2
     */
    tenant: string;
    /**
     * The resource name of the task to subscribe to.
     * Format: tasks/{task_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.ListTaskPushNotificationConfigRequest
 */
export interface ListTaskPushNotificationConfigRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 4
     */
    tenant: string;
    /**
     * The parent task resource.
     * Format: tasks/{task_id}
     *
     * @generated from protobuf field: string parent = 1
     */
    parent: string;
    /**
     * The maximum number of configurations to return.
     *
     * @generated from protobuf field: int32 page_size = 2
     */
    pageSize: number;
    /**
     * A page token received from a previous ListTaskPushNotificationConfigRequest call.
     *
     * @generated from protobuf field: string page_token = 3
     */
    pageToken: string;
}
/**
 * @generated from protobuf message a2a.v1.GetExtendedAgentCardRequest
 */
export interface GetExtendedAgentCardRequest {
    /**
     * Optional tenant, provided as a path parameter.
     *
     * @generated from protobuf field: string tenant = 1
     */
    tenant: string;
}
/**
 * ////// Response Messages ///////////
 *
 * @generated from protobuf message a2a.v1.SendMessageResponse
 */
export interface SendMessageResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "task";
        /**
         * @generated from protobuf field: a2a.v1.Task task = 1
         */
        task: Task;
    } | {
        oneofKind: "msg";
        /**
         * @generated from protobuf field: a2a.v1.Message msg = 2 [json_name = "message"]
         */
        msg: Message;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A wrapper object used in streaming operations to encapsulate different types of response data.
 *
 * @generated from protobuf message a2a.v1.StreamResponse
 */
export interface StreamResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "task";
        /**
         * A Task object containing the current state of the task.
         *
         * @generated from protobuf field: a2a.v1.Task task = 1
         */
        task: Task;
    } | {
        oneofKind: "msg";
        /**
         * A Message object containing a message from the agent.
         *
         * @generated from protobuf field: a2a.v1.Message msg = 2 [json_name = "message"]
         */
        msg: Message;
    } | {
        oneofKind: "statusUpdate";
        /**
         * An event indicating a task status update.
         *
         * @generated from protobuf field: a2a.v1.TaskStatusUpdateEvent status_update = 3
         */
        statusUpdate: TaskStatusUpdateEvent;
    } | {
        oneofKind: "artifactUpdate";
        /**
         * An event indicating a task artifact update.
         *
         * @generated from protobuf field: a2a.v1.TaskArtifactUpdateEvent artifact_update = 4
         */
        artifactUpdate: TaskArtifactUpdateEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Represents a successful response for the `tasks/pushNotificationConfig/list`
 * method.
 *
 * @generated from protobuf message a2a.v1.ListTaskPushNotificationConfigResponse
 */
export interface ListTaskPushNotificationConfigResponse {
    /**
     * The list of push notification configurations.
     *
     * @generated from protobuf field: repeated a2a.v1.TaskPushNotificationConfig configs = 1
     */
    configs: TaskPushNotificationConfig[];
    /**
     * A token, which can be sent as `page_token` to retrieve the next page.
     * If this field is omitted, there are no subsequent pages.
     *
     * @generated from protobuf field: string next_page_token = 2
     */
    nextPageToken: string;
}
/**
 * Defines the possible lifecycle states of a Task.
 *
 * @generated from protobuf enum a2a.v1.TaskState
 */
export enum TaskState {
    /**
     * The task is in an unknown or indeterminate state.
     *
     * @generated from protobuf enum value: TASK_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Represents the status that acknowledges a task is created.
     *
     * @generated from protobuf enum value: TASK_STATE_SUBMITTED = 1;
     */
    SUBMITTED = 1,
    /**
     * Represents the status that a task is actively being processed.
     *
     * @generated from protobuf enum value: TASK_STATE_WORKING = 2;
     */
    WORKING = 2,
    /**
     * Represents the status a task is finished. This is a terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_COMPLETED = 3;
     */
    COMPLETED = 3,
    /**
     * Represents the status a task is done but failed. This is a terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_FAILED = 4;
     */
    FAILED = 4,
    /**
     * Represents the status a task was cancelled before it finished.
     * This is a terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_CANCELLED = 5;
     */
    CANCELLED = 5,
    /**
     * Represents the status that the task requires information to complete.
     * This is an interrupted state.
     *
     * @generated from protobuf enum value: TASK_STATE_INPUT_REQUIRED = 6;
     */
    INPUT_REQUIRED = 6,
    /**
     * Represents the status that the agent has decided to not perform the task.
     * This may be done during initial task creation or later once an agent
     * has determined it can't or won't proceed. This is a terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_REJECTED = 7;
     */
    REJECTED = 7,
    /**
     * Represents the state that some authentication is needed from the upstream
     * client. Authentication is expected to come out-of-band thus this is not
     * an interrupted or terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_AUTH_REQUIRED = 8;
     */
    AUTH_REQUIRED = 8
}
/**
 * Defines the sender of a message in A2A protocol communication.
 *
 * @generated from protobuf enum a2a.v1.Role
 */
export enum Role {
    /**
     * @generated from protobuf enum value: ROLE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * USER role refers to communication from the client to the server.
     *
     * @generated from protobuf enum value: ROLE_USER = 1;
     */
    USER = 1,
    /**
     * AGENT role refers to communication from the server to the client.
     *
     * @generated from protobuf enum value: ROLE_AGENT = 2;
     */
    AGENT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageConfiguration$Type extends MessageType<SendMessageConfiguration> {
    constructor() {
        super("a2a.v1.SendMessageConfiguration", [
            { no: 1, name: "accepted_output_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "push_notification_config", kind: "message", T: () => PushNotificationConfig },
            { no: 3, name: "history_length", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "blocking", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SendMessageConfiguration>): SendMessageConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.acceptedOutputModes = [];
        message.blocking = false;
        if (value !== undefined)
            reflectionMergePartial<SendMessageConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageConfiguration): SendMessageConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accepted_output_modes */ 1:
                    message.acceptedOutputModes.push(reader.string());
                    break;
                case /* a2a.v1.PushNotificationConfig push_notification_config */ 2:
                    message.pushNotificationConfig = PushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.pushNotificationConfig);
                    break;
                case /* optional int32 history_length */ 3:
                    message.historyLength = reader.int32();
                    break;
                case /* bool blocking */ 4:
                    message.blocking = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accepted_output_modes = 1; */
        for (let i = 0; i < message.acceptedOutputModes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.acceptedOutputModes[i]);
        /* a2a.v1.PushNotificationConfig push_notification_config = 2; */
        if (message.pushNotificationConfig)
            PushNotificationConfig.internalBinaryWrite(message.pushNotificationConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 history_length = 3; */
        if (message.historyLength !== undefined)
            writer.tag(3, WireType.Varint).int32(message.historyLength);
        /* bool blocking = 4; */
        if (message.blocking !== false)
            writer.tag(4, WireType.Varint).bool(message.blocking);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SendMessageConfiguration
 */
export const SendMessageConfiguration = new SendMessageConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("a2a.v1.Task", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "status", kind: "message", T: () => TaskStatus, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "artifacts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Artifact },
            { no: 5, name: "history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Message },
            { no: 6, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.contextId = "";
        message.artifacts = [];
        message.history = [];
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.TaskStatus status */ 3:
                    message.status = TaskStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* repeated a2a.v1.Artifact artifacts */ 4:
                    message.artifacts.push(Artifact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated a2a.v1.Message history */ 5:
                    message.history.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.TaskStatus status = 3; */
        if (message.status)
            TaskStatus.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated a2a.v1.Artifact artifacts = 4; */
        for (let i = 0; i < message.artifacts.length; i++)
            Artifact.internalBinaryWrite(message.artifacts[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated a2a.v1.Message history = 5; */
        for (let i = 0; i < message.history.length; i++)
            Message.internalBinaryWrite(message.history[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskStatus$Type extends MessageType<TaskStatus> {
    constructor() {
        super("a2a.v1.TaskStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["a2a.v1.TaskState", TaskState, "TASK_STATE_"], options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "message", kind: "message", T: () => Message },
            { no: 3, name: "timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TaskStatus>): TaskStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskStatus): TaskStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.TaskState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* a2a.v1.Message message */ 2:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* google.protobuf.Timestamp timestamp */ 3:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.TaskState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* a2a.v1.Message message = 2; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp timestamp = 3; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskStatus
 */
export const TaskStatus = new TaskStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Part$Type extends MessageType<Part> {
    constructor() {
        super("a2a.v1.Part", [
            { no: 1, name: "text", kind: "scalar", oneof: "part", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file", kind: "message", oneof: "part", T: () => FilePart },
            { no: 3, name: "data", kind: "message", oneof: "part", T: () => DataPart },
            { no: 4, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Part>): Part {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.part = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Part>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Part): Part {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.part = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* a2a.v1.FilePart file */ 2:
                    message.part = {
                        oneofKind: "file",
                        file: FilePart.internalBinaryRead(reader, reader.uint32(), options, (message.part as any).file)
                    };
                    break;
                case /* a2a.v1.DataPart data */ 3:
                    message.part = {
                        oneofKind: "data",
                        data: DataPart.internalBinaryRead(reader, reader.uint32(), options, (message.part as any).data)
                    };
                    break;
                case /* google.protobuf.Struct metadata */ 4:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Part, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.part.oneofKind === "text")
            writer.tag(1, WireType.LengthDelimited).string(message.part.text);
        /* a2a.v1.FilePart file = 2; */
        if (message.part.oneofKind === "file")
            FilePart.internalBinaryWrite(message.part.file, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.DataPart data = 3; */
        if (message.part.oneofKind === "data")
            DataPart.internalBinaryWrite(message.part.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 4; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Part
 */
export const Part = new Part$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilePart$Type extends MessageType<FilePart> {
    constructor() {
        super("a2a.v1.FilePart", [
            { no: 1, name: "file_with_uri", kind: "scalar", oneof: "file", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file_with_bytes", kind: "scalar", oneof: "file", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "media_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FilePart>): FilePart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.file = { oneofKind: undefined };
        message.mediaType = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<FilePart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilePart): FilePart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_with_uri */ 1:
                    message.file = {
                        oneofKind: "fileWithUri",
                        fileWithUri: reader.string()
                    };
                    break;
                case /* bytes file_with_bytes */ 2:
                    message.file = {
                        oneofKind: "fileWithBytes",
                        fileWithBytes: reader.bytes()
                    };
                    break;
                case /* string media_type */ 3:
                    message.mediaType = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilePart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_with_uri = 1; */
        if (message.file.oneofKind === "fileWithUri")
            writer.tag(1, WireType.LengthDelimited).string(message.file.fileWithUri);
        /* bytes file_with_bytes = 2; */
        if (message.file.oneofKind === "fileWithBytes")
            writer.tag(2, WireType.LengthDelimited).bytes(message.file.fileWithBytes);
        /* string media_type = 3; */
        if (message.mediaType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.mediaType);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.FilePart
 */
export const FilePart = new FilePart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataPart$Type extends MessageType<DataPart> {
    constructor() {
        super("a2a.v1.DataPart", [
            { no: 1, name: "data", kind: "message", T: () => Struct, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<DataPart>): DataPart {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DataPart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataPart): DataPart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct data */ 1:
                    message.data = Struct.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataPart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct data = 1; */
        if (message.data)
            Struct.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.DataPart
 */
export const DataPart = new DataPart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("a2a.v1.Message", [
            { no: 1, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "role", kind: "enum", T: () => ["a2a.v1.Role", Role, "ROLE_"], options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 5, name: "parts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Part, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 6, name: "metadata", kind: "message", T: () => Struct },
            { no: 7, name: "extensions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "reference_task_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = "";
        message.contextId = "";
        message.taskId = "";
        message.role = 0;
        message.parts = [];
        message.extensions = [];
        message.referenceTaskIds = [];
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_id */ 1:
                    message.messageId = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* string task_id */ 3:
                    message.taskId = reader.string();
                    break;
                case /* a2a.v1.Role role */ 4:
                    message.role = reader.int32();
                    break;
                case /* repeated a2a.v1.Part parts */ 5:
                    message.parts.push(Part.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* repeated string extensions */ 7:
                    message.extensions.push(reader.string());
                    break;
                case /* repeated string reference_task_ids */ 8:
                    message.referenceTaskIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_id = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* string task_id = 3; */
        if (message.taskId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.taskId);
        /* a2a.v1.Role role = 4; */
        if (message.role !== 0)
            writer.tag(4, WireType.Varint).int32(message.role);
        /* repeated a2a.v1.Part parts = 5; */
        for (let i = 0; i < message.parts.length; i++)
            Part.internalBinaryWrite(message.parts[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string extensions = 7; */
        for (let i = 0; i < message.extensions.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.extensions[i]);
        /* repeated string reference_task_ids = 8; */
        for (let i = 0; i < message.referenceTaskIds.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.referenceTaskIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Artifact$Type extends MessageType<Artifact> {
    constructor() {
        super("a2a.v1.Artifact", [
            { no: 1, name: "artifact_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Part, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 6, name: "metadata", kind: "message", T: () => Struct },
            { no: 7, name: "extensions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Artifact>): Artifact {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.artifactId = "";
        message.name = "";
        message.description = "";
        message.parts = [];
        message.extensions = [];
        if (value !== undefined)
            reflectionMergePartial<Artifact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Artifact): Artifact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string artifact_id */ 1:
                    message.artifactId = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated a2a.v1.Part parts */ 5:
                    message.parts.push(Part.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* repeated string extensions */ 7:
                    message.extensions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Artifact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string artifact_id = 1; */
        if (message.artifactId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.artifactId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated a2a.v1.Part parts = 5; */
        for (let i = 0; i < message.parts.length; i++)
            Part.internalBinaryWrite(message.parts[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string extensions = 7; */
        for (let i = 0; i < message.extensions.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.extensions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Artifact
 */
export const Artifact = new Artifact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskStatusUpdateEvent$Type extends MessageType<TaskStatusUpdateEvent> {
    constructor() {
        super("a2a.v1.TaskStatusUpdateEvent", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "status", kind: "message", T: () => TaskStatus, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "final", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 5, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<TaskStatusUpdateEvent>): TaskStatusUpdateEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = "";
        message.contextId = "";
        message.final = false;
        if (value !== undefined)
            reflectionMergePartial<TaskStatusUpdateEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskStatusUpdateEvent): TaskStatusUpdateEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.TaskStatus status */ 3:
                    message.status = TaskStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* bool final */ 4:
                    message.final = reader.bool();
                    break;
                case /* google.protobuf.Struct metadata */ 5:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskStatusUpdateEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.TaskStatus status = 3; */
        if (message.status)
            TaskStatus.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool final = 4; */
        if (message.final !== false)
            writer.tag(4, WireType.Varint).bool(message.final);
        /* google.protobuf.Struct metadata = 5; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskStatusUpdateEvent
 */
export const TaskStatusUpdateEvent = new TaskStatusUpdateEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskArtifactUpdateEvent$Type extends MessageType<TaskArtifactUpdateEvent> {
    constructor() {
        super("a2a.v1.TaskArtifactUpdateEvent", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "artifact", kind: "message", T: () => Artifact, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "append", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "last_chunk", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<TaskArtifactUpdateEvent>): TaskArtifactUpdateEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = "";
        message.contextId = "";
        message.append = false;
        message.lastChunk = false;
        if (value !== undefined)
            reflectionMergePartial<TaskArtifactUpdateEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskArtifactUpdateEvent): TaskArtifactUpdateEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.Artifact artifact */ 3:
                    message.artifact = Artifact.internalBinaryRead(reader, reader.uint32(), options, message.artifact);
                    break;
                case /* bool append */ 4:
                    message.append = reader.bool();
                    break;
                case /* bool last_chunk */ 5:
                    message.lastChunk = reader.bool();
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskArtifactUpdateEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.Artifact artifact = 3; */
        if (message.artifact)
            Artifact.internalBinaryWrite(message.artifact, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool append = 4; */
        if (message.append !== false)
            writer.tag(4, WireType.Varint).bool(message.append);
        /* bool last_chunk = 5; */
        if (message.lastChunk !== false)
            writer.tag(5, WireType.Varint).bool(message.lastChunk);
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskArtifactUpdateEvent
 */
export const TaskArtifactUpdateEvent = new TaskArtifactUpdateEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushNotificationConfig$Type extends MessageType<PushNotificationConfig> {
    constructor() {
        super("a2a.v1.PushNotificationConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authentication", kind: "message", T: () => AuthenticationInfo }
        ]);
    }
    create(value?: PartialMessage<PushNotificationConfig>): PushNotificationConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.url = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<PushNotificationConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushNotificationConfig): PushNotificationConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                case /* a2a.v1.AuthenticationInfo authentication */ 4:
                    message.authentication = AuthenticationInfo.internalBinaryRead(reader, reader.uint32(), options, message.authentication);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushNotificationConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* a2a.v1.AuthenticationInfo authentication = 4; */
        if (message.authentication)
            AuthenticationInfo.internalBinaryWrite(message.authentication, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.PushNotificationConfig
 */
export const PushNotificationConfig = new PushNotificationConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticationInfo$Type extends MessageType<AuthenticationInfo> {
    constructor() {
        super("a2a.v1.AuthenticationInfo", [
            { no: 1, name: "schemes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "credentials", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticationInfo>): AuthenticationInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemes = [];
        message.credentials = "";
        if (value !== undefined)
            reflectionMergePartial<AuthenticationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticationInfo): AuthenticationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string schemes */ 1:
                    message.schemes.push(reader.string());
                    break;
                case /* string credentials */ 2:
                    message.credentials = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string schemes = 1; */
        for (let i = 0; i < message.schemes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.schemes[i]);
        /* string credentials = 2; */
        if (message.credentials !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentials);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AuthenticationInfo
 */
export const AuthenticationInfo = new AuthenticationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentInterface$Type extends MessageType<AgentInterface> {
    constructor() {
        super("a2a.v1.AgentInterface", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "protocol_binding", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AgentInterface>): AgentInterface {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.protocolBinding = "";
        message.tenant = "";
        if (value !== undefined)
            reflectionMergePartial<AgentInterface>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentInterface): AgentInterface {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string protocol_binding */ 2:
                    message.protocolBinding = reader.string();
                    break;
                case /* string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentInterface, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string protocol_binding = 2; */
        if (message.protocolBinding !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protocolBinding);
        /* string tenant = 3; */
        if (message.tenant !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentInterface
 */
export const AgentInterface = new AgentInterface$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentCard$Type extends MessageType<AgentCard> {
    constructor() {
        super("a2a.v1.AgentCard", [
            { no: 16, name: "protocol_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 19, name: "supported_interfaces", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentInterface },
            { no: 3, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "preferred_transport", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "additional_interfaces", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentInterface },
            { no: 4, name: "provider", kind: "message", T: () => AgentProvider },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 6, name: "documentation_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "capabilities", kind: "message", T: () => AgentCapabilities, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 8, name: "security_schemes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SecurityScheme } },
            { no: 9, name: "security", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Security },
            { no: 10, name: "default_input_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 11, name: "default_output_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 12, name: "skills", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentSkill, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 13, name: "supports_extended_agent_card", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "signatures", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentCardSignature },
            { no: 18, name: "icon_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AgentCard>): AgentCard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.description = "";
        message.supportedInterfaces = [];
        message.additionalInterfaces = [];
        message.version = "";
        message.securitySchemes = {};
        message.security = [];
        message.defaultInputModes = [];
        message.defaultOutputModes = [];
        message.skills = [];
        message.signatures = [];
        if (value !== undefined)
            reflectionMergePartial<AgentCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentCard): AgentCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string protocol_version */ 16:
                    message.protocolVersion = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated a2a.v1.AgentInterface supported_interfaces */ 19:
                    message.supportedInterfaces.push(AgentInterface.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string url = 3 [deprecated = true] */ 3:
                    message.url = reader.string();
                    break;
                case /* optional string preferred_transport = 14 [deprecated = true] */ 14:
                    message.preferredTransport = reader.string();
                    break;
                case /* repeated a2a.v1.AgentInterface additional_interfaces = 15 [deprecated = true] */ 15:
                    message.additionalInterfaces.push(AgentInterface.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* a2a.v1.AgentProvider provider */ 4:
                    message.provider = AgentProvider.internalBinaryRead(reader, reader.uint32(), options, message.provider);
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* optional string documentation_url */ 6:
                    message.documentationUrl = reader.string();
                    break;
                case /* a2a.v1.AgentCapabilities capabilities */ 7:
                    message.capabilities = AgentCapabilities.internalBinaryRead(reader, reader.uint32(), options, message.capabilities);
                    break;
                case /* map<string, a2a.v1.SecurityScheme> security_schemes */ 8:
                    this.binaryReadMap8(message.securitySchemes, reader, options);
                    break;
                case /* repeated a2a.v1.Security security */ 9:
                    message.security.push(Security.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string default_input_modes */ 10:
                    message.defaultInputModes.push(reader.string());
                    break;
                case /* repeated string default_output_modes */ 11:
                    message.defaultOutputModes.push(reader.string());
                    break;
                case /* repeated a2a.v1.AgentSkill skills */ 12:
                    message.skills.push(AgentSkill.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool supports_extended_agent_card */ 13:
                    message.supportsExtendedAgentCard = reader.bool();
                    break;
                case /* repeated a2a.v1.AgentCardSignature signatures */ 17:
                    message.signatures.push(AgentCardSignature.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string icon_url */ 18:
                    message.iconUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: AgentCard["securitySchemes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AgentCard["securitySchemes"] | undefined, val: AgentCard["securitySchemes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SecurityScheme.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.AgentCard.security_schemes");
            }
        }
        map[key ?? ""] = val ?? SecurityScheme.create();
    }
    internalBinaryWrite(message: AgentCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* optional string url = 3 [deprecated = true]; */
        if (message.url !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* a2a.v1.AgentProvider provider = 4; */
        if (message.provider)
            AgentProvider.internalBinaryWrite(message.provider, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* optional string documentation_url = 6; */
        if (message.documentationUrl !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.documentationUrl);
        /* a2a.v1.AgentCapabilities capabilities = 7; */
        if (message.capabilities)
            AgentCapabilities.internalBinaryWrite(message.capabilities, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* map<string, a2a.v1.SecurityScheme> security_schemes = 8; */
        for (let k of globalThis.Object.keys(message.securitySchemes)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SecurityScheme.internalBinaryWrite(message.securitySchemes[k], writer, options);
            writer.join().join();
        }
        /* repeated a2a.v1.Security security = 9; */
        for (let i = 0; i < message.security.length; i++)
            Security.internalBinaryWrite(message.security[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string default_input_modes = 10; */
        for (let i = 0; i < message.defaultInputModes.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.defaultInputModes[i]);
        /* repeated string default_output_modes = 11; */
        for (let i = 0; i < message.defaultOutputModes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.defaultOutputModes[i]);
        /* repeated a2a.v1.AgentSkill skills = 12; */
        for (let i = 0; i < message.skills.length; i++)
            AgentSkill.internalBinaryWrite(message.skills[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional bool supports_extended_agent_card = 13; */
        if (message.supportsExtendedAgentCard !== undefined)
            writer.tag(13, WireType.Varint).bool(message.supportsExtendedAgentCard);
        /* optional string preferred_transport = 14 [deprecated = true]; */
        if (message.preferredTransport !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.preferredTransport);
        /* repeated a2a.v1.AgentInterface additional_interfaces = 15 [deprecated = true]; */
        for (let i = 0; i < message.additionalInterfaces.length; i++)
            AgentInterface.internalBinaryWrite(message.additionalInterfaces[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional string protocol_version = 16; */
        if (message.protocolVersion !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.protocolVersion);
        /* repeated a2a.v1.AgentCardSignature signatures = 17; */
        for (let i = 0; i < message.signatures.length; i++)
            AgentCardSignature.internalBinaryWrite(message.signatures[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional string icon_url = 18; */
        if (message.iconUrl !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.iconUrl);
        /* repeated a2a.v1.AgentInterface supported_interfaces = 19; */
        for (let i = 0; i < message.supportedInterfaces.length; i++)
            AgentInterface.internalBinaryWrite(message.supportedInterfaces[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentCard
 */
export const AgentCard = new AgentCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentProvider$Type extends MessageType<AgentProvider> {
    constructor() {
        super("a2a.v1.AgentProvider", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "organization", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<AgentProvider>): AgentProvider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.organization = "";
        if (value !== undefined)
            reflectionMergePartial<AgentProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentProvider): AgentProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string organization */ 2:
                    message.organization = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string organization = 2; */
        if (message.organization !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.organization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentProvider
 */
export const AgentProvider = new AgentProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentCapabilities$Type extends MessageType<AgentCapabilities> {
    constructor() {
        super("a2a.v1.AgentCapabilities", [
            { no: 1, name: "streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "push_notifications", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "extensions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentExtension },
            { no: 4, name: "state_transition_history", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AgentCapabilities>): AgentCapabilities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extensions = [];
        if (value !== undefined)
            reflectionMergePartial<AgentCapabilities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentCapabilities): AgentCapabilities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool streaming */ 1:
                    message.streaming = reader.bool();
                    break;
                case /* optional bool push_notifications */ 2:
                    message.pushNotifications = reader.bool();
                    break;
                case /* repeated a2a.v1.AgentExtension extensions */ 3:
                    message.extensions.push(AgentExtension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool state_transition_history */ 4:
                    message.stateTransitionHistory = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentCapabilities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool streaming = 1; */
        if (message.streaming !== undefined)
            writer.tag(1, WireType.Varint).bool(message.streaming);
        /* optional bool push_notifications = 2; */
        if (message.pushNotifications !== undefined)
            writer.tag(2, WireType.Varint).bool(message.pushNotifications);
        /* repeated a2a.v1.AgentExtension extensions = 3; */
        for (let i = 0; i < message.extensions.length; i++)
            AgentExtension.internalBinaryWrite(message.extensions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool state_transition_history = 4; */
        if (message.stateTransitionHistory !== undefined)
            writer.tag(4, WireType.Varint).bool(message.stateTransitionHistory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentCapabilities
 */
export const AgentCapabilities = new AgentCapabilities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentExtension$Type extends MessageType<AgentExtension> {
    constructor() {
        super("a2a.v1.AgentExtension", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "params", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<AgentExtension>): AgentExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        message.description = "";
        message.required = false;
        if (value !== undefined)
            reflectionMergePartial<AgentExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentExtension): AgentExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* bool required */ 3:
                    message.required = reader.bool();
                    break;
                case /* google.protobuf.Struct params */ 4:
                    message.params = Struct.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* bool required = 3; */
        if (message.required !== false)
            writer.tag(3, WireType.Varint).bool(message.required);
        /* google.protobuf.Struct params = 4; */
        if (message.params)
            Struct.internalBinaryWrite(message.params, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentExtension
 */
export const AgentExtension = new AgentExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentSkill$Type extends MessageType<AgentSkill> {
    constructor() {
        super("a2a.v1.AgentSkill", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 5, name: "examples", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "input_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "output_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "security", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Security }
        ]);
    }
    create(value?: PartialMessage<AgentSkill>): AgentSkill {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.tags = [];
        message.examples = [];
        message.inputModes = [];
        message.outputModes = [];
        message.security = [];
        if (value !== undefined)
            reflectionMergePartial<AgentSkill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentSkill): AgentSkill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* repeated string tags */ 4:
                    message.tags.push(reader.string());
                    break;
                case /* repeated string examples */ 5:
                    message.examples.push(reader.string());
                    break;
                case /* repeated string input_modes */ 6:
                    message.inputModes.push(reader.string());
                    break;
                case /* repeated string output_modes */ 7:
                    message.outputModes.push(reader.string());
                    break;
                case /* repeated a2a.v1.Security security */ 8:
                    message.security.push(Security.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentSkill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* repeated string tags = 4; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.tags[i]);
        /* repeated string examples = 5; */
        for (let i = 0; i < message.examples.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.examples[i]);
        /* repeated string input_modes = 6; */
        for (let i = 0; i < message.inputModes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.inputModes[i]);
        /* repeated string output_modes = 7; */
        for (let i = 0; i < message.outputModes.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.outputModes[i]);
        /* repeated a2a.v1.Security security = 8; */
        for (let i = 0; i < message.security.length; i++)
            Security.internalBinaryWrite(message.security[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentSkill
 */
export const AgentSkill = new AgentSkill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentCardSignature$Type extends MessageType<AgentCardSignature> {
    constructor() {
        super("a2a.v1.AgentCardSignature", [
            { no: 1, name: "protected", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "header", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<AgentCardSignature>): AgentCardSignature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protected = "";
        message.signature = "";
        if (value !== undefined)
            reflectionMergePartial<AgentCardSignature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentCardSignature): AgentCardSignature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string protected */ 1:
                    message.protected = reader.string();
                    break;
                case /* string signature */ 2:
                    message.signature = reader.string();
                    break;
                case /* google.protobuf.Struct header */ 3:
                    message.header = Struct.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentCardSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string protected = 1; */
        if (message.protected !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.protected);
        /* string signature = 2; */
        if (message.signature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signature);
        /* google.protobuf.Struct header = 3; */
        if (message.header)
            Struct.internalBinaryWrite(message.header, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentCardSignature
 */
export const AgentCardSignature = new AgentCardSignature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskPushNotificationConfig$Type extends MessageType<TaskPushNotificationConfig> {
    constructor() {
        super("a2a.v1.TaskPushNotificationConfig", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "push_notification_config", kind: "message", T: () => PushNotificationConfig, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<TaskPushNotificationConfig>): TaskPushNotificationConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<TaskPushNotificationConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskPushNotificationConfig): TaskPushNotificationConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* a2a.v1.PushNotificationConfig push_notification_config */ 2:
                    message.pushNotificationConfig = PushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.pushNotificationConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskPushNotificationConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* a2a.v1.PushNotificationConfig push_notification_config = 2; */
        if (message.pushNotificationConfig)
            PushNotificationConfig.internalBinaryWrite(message.pushNotificationConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskPushNotificationConfig
 */
export const TaskPushNotificationConfig = new TaskPushNotificationConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringList$Type extends MessageType<StringList> {
    constructor() {
        super("a2a.v1.StringList", [
            { no: 1, name: "list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StringList>): StringList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<StringList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringList): StringList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string list */ 1:
                    message.list.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string list = 1; */
        for (let i = 0; i < message.list.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.list[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.StringList
 */
export const StringList = new StringList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Security$Type extends MessageType<Security> {
    constructor() {
        super("a2a.v1.Security", [
            { no: 1, name: "schemes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => StringList } }
        ]);
    }
    create(value?: PartialMessage<Security>): Security {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemes = {};
        if (value !== undefined)
            reflectionMergePartial<Security>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Security): Security {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, a2a.v1.StringList> schemes */ 1:
                    this.binaryReadMap1(message.schemes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Security["schemes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Security["schemes"] | undefined, val: Security["schemes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = StringList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.Security.schemes");
            }
        }
        map[key ?? ""] = val ?? StringList.create();
    }
    internalBinaryWrite(message: Security, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, a2a.v1.StringList> schemes = 1; */
        for (let k of globalThis.Object.keys(message.schemes)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            StringList.internalBinaryWrite(message.schemes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Security
 */
export const Security = new Security$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityScheme$Type extends MessageType<SecurityScheme> {
    constructor() {
        super("a2a.v1.SecurityScheme", [
            { no: 1, name: "api_key_security_scheme", kind: "message", oneof: "scheme", T: () => APIKeySecurityScheme },
            { no: 2, name: "http_auth_security_scheme", kind: "message", oneof: "scheme", T: () => HTTPAuthSecurityScheme },
            { no: 3, name: "oauth2_security_scheme", kind: "message", oneof: "scheme", T: () => OAuth2SecurityScheme },
            { no: 4, name: "open_id_connect_security_scheme", kind: "message", oneof: "scheme", T: () => OpenIdConnectSecurityScheme },
            { no: 5, name: "mtls_security_scheme", kind: "message", oneof: "scheme", T: () => MutualTlsSecurityScheme }
        ]);
    }
    create(value?: PartialMessage<SecurityScheme>): SecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scheme = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityScheme): SecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.APIKeySecurityScheme api_key_security_scheme */ 1:
                    message.scheme = {
                        oneofKind: "apiKeySecurityScheme",
                        apiKeySecurityScheme: APIKeySecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).apiKeySecurityScheme)
                    };
                    break;
                case /* a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme */ 2:
                    message.scheme = {
                        oneofKind: "httpAuthSecurityScheme",
                        httpAuthSecurityScheme: HTTPAuthSecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).httpAuthSecurityScheme)
                    };
                    break;
                case /* a2a.v1.OAuth2SecurityScheme oauth2_security_scheme */ 3:
                    message.scheme = {
                        oneofKind: "oauth2SecurityScheme",
                        oauth2SecurityScheme: OAuth2SecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).oauth2SecurityScheme)
                    };
                    break;
                case /* a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme */ 4:
                    message.scheme = {
                        oneofKind: "openIdConnectSecurityScheme",
                        openIdConnectSecurityScheme: OpenIdConnectSecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).openIdConnectSecurityScheme)
                    };
                    break;
                case /* a2a.v1.MutualTlsSecurityScheme mtls_security_scheme */ 5:
                    message.scheme = {
                        oneofKind: "mtlsSecurityScheme",
                        mtlsSecurityScheme: MutualTlsSecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).mtlsSecurityScheme)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.APIKeySecurityScheme api_key_security_scheme = 1; */
        if (message.scheme.oneofKind === "apiKeySecurityScheme")
            APIKeySecurityScheme.internalBinaryWrite(message.scheme.apiKeySecurityScheme, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme = 2; */
        if (message.scheme.oneofKind === "httpAuthSecurityScheme")
            HTTPAuthSecurityScheme.internalBinaryWrite(message.scheme.httpAuthSecurityScheme, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.OAuth2SecurityScheme oauth2_security_scheme = 3; */
        if (message.scheme.oneofKind === "oauth2SecurityScheme")
            OAuth2SecurityScheme.internalBinaryWrite(message.scheme.oauth2SecurityScheme, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4; */
        if (message.scheme.oneofKind === "openIdConnectSecurityScheme")
            OpenIdConnectSecurityScheme.internalBinaryWrite(message.scheme.openIdConnectSecurityScheme, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.MutualTlsSecurityScheme mtls_security_scheme = 5; */
        if (message.scheme.oneofKind === "mtlsSecurityScheme")
            MutualTlsSecurityScheme.internalBinaryWrite(message.scheme.mtlsSecurityScheme, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SecurityScheme
 */
export const SecurityScheme = new SecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APIKeySecurityScheme$Type extends MessageType<APIKeySecurityScheme> {
    constructor() {
        super("a2a.v1.APIKeySecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<APIKeySecurityScheme>): APIKeySecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.location = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<APIKeySecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APIKeySecurityScheme): APIKeySecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string location */ 2:
                    message.location = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APIKeySecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string location = 2; */
        if (message.location !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.location);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.APIKeySecurityScheme
 */
export const APIKeySecurityScheme = new APIKeySecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPAuthSecurityScheme$Type extends MessageType<HTTPAuthSecurityScheme> {
    constructor() {
        super("a2a.v1.HTTPAuthSecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scheme", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "bearer_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HTTPAuthSecurityScheme>): HTTPAuthSecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.scheme = "";
        message.bearerFormat = "";
        if (value !== undefined)
            reflectionMergePartial<HTTPAuthSecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPAuthSecurityScheme): HTTPAuthSecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string scheme */ 2:
                    message.scheme = reader.string();
                    break;
                case /* string bearer_format */ 3:
                    message.bearerFormat = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPAuthSecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string scheme = 2; */
        if (message.scheme !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.scheme);
        /* string bearer_format = 3; */
        if (message.bearerFormat !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bearerFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.HTTPAuthSecurityScheme
 */
export const HTTPAuthSecurityScheme = new HTTPAuthSecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OAuth2SecurityScheme$Type extends MessageType<OAuth2SecurityScheme> {
    constructor() {
        super("a2a.v1.OAuth2SecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "flows", kind: "message", T: () => OAuthFlows, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "oauth2_metadata_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OAuth2SecurityScheme>): OAuth2SecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.oauth2MetadataUrl = "";
        if (value !== undefined)
            reflectionMergePartial<OAuth2SecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OAuth2SecurityScheme): OAuth2SecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* a2a.v1.OAuthFlows flows */ 2:
                    message.flows = OAuthFlows.internalBinaryRead(reader, reader.uint32(), options, message.flows);
                    break;
                case /* string oauth2_metadata_url */ 3:
                    message.oauth2MetadataUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OAuth2SecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* a2a.v1.OAuthFlows flows = 2; */
        if (message.flows)
            OAuthFlows.internalBinaryWrite(message.flows, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string oauth2_metadata_url = 3; */
        if (message.oauth2MetadataUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.oauth2MetadataUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.OAuth2SecurityScheme
 */
export const OAuth2SecurityScheme = new OAuth2SecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenIdConnectSecurityScheme$Type extends MessageType<OpenIdConnectSecurityScheme> {
    constructor() {
        super("a2a.v1.OpenIdConnectSecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open_id_connect_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<OpenIdConnectSecurityScheme>): OpenIdConnectSecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.openIdConnectUrl = "";
        if (value !== undefined)
            reflectionMergePartial<OpenIdConnectSecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenIdConnectSecurityScheme): OpenIdConnectSecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string open_id_connect_url */ 2:
                    message.openIdConnectUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenIdConnectSecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string open_id_connect_url = 2; */
        if (message.openIdConnectUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.openIdConnectUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.OpenIdConnectSecurityScheme
 */
export const OpenIdConnectSecurityScheme = new OpenIdConnectSecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MutualTlsSecurityScheme$Type extends MessageType<MutualTlsSecurityScheme> {
    constructor() {
        super("a2a.v1.MutualTlsSecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MutualTlsSecurityScheme>): MutualTlsSecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<MutualTlsSecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MutualTlsSecurityScheme): MutualTlsSecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MutualTlsSecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.MutualTlsSecurityScheme
 */
export const MutualTlsSecurityScheme = new MutualTlsSecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OAuthFlows$Type extends MessageType<OAuthFlows> {
    constructor() {
        super("a2a.v1.OAuthFlows", [
            { no: 1, name: "authorization_code", kind: "message", oneof: "flow", T: () => AuthorizationCodeOAuthFlow },
            { no: 2, name: "client_credentials", kind: "message", oneof: "flow", T: () => ClientCredentialsOAuthFlow },
            { no: 3, name: "implicit", kind: "message", oneof: "flow", T: () => ImplicitOAuthFlow },
            { no: 4, name: "password", kind: "message", oneof: "flow", T: () => PasswordOAuthFlow }
        ]);
    }
    create(value?: PartialMessage<OAuthFlows>): OAuthFlows {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flow = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OAuthFlows>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OAuthFlows): OAuthFlows {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.AuthorizationCodeOAuthFlow authorization_code */ 1:
                    message.flow = {
                        oneofKind: "authorizationCode",
                        authorizationCode: AuthorizationCodeOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).authorizationCode)
                    };
                    break;
                case /* a2a.v1.ClientCredentialsOAuthFlow client_credentials */ 2:
                    message.flow = {
                        oneofKind: "clientCredentials",
                        clientCredentials: ClientCredentialsOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).clientCredentials)
                    };
                    break;
                case /* a2a.v1.ImplicitOAuthFlow implicit */ 3:
                    message.flow = {
                        oneofKind: "implicit",
                        implicit: ImplicitOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).implicit)
                    };
                    break;
                case /* a2a.v1.PasswordOAuthFlow password */ 4:
                    message.flow = {
                        oneofKind: "password",
                        password: PasswordOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).password)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OAuthFlows, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.AuthorizationCodeOAuthFlow authorization_code = 1; */
        if (message.flow.oneofKind === "authorizationCode")
            AuthorizationCodeOAuthFlow.internalBinaryWrite(message.flow.authorizationCode, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.ClientCredentialsOAuthFlow client_credentials = 2; */
        if (message.flow.oneofKind === "clientCredentials")
            ClientCredentialsOAuthFlow.internalBinaryWrite(message.flow.clientCredentials, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.ImplicitOAuthFlow implicit = 3; */
        if (message.flow.oneofKind === "implicit")
            ImplicitOAuthFlow.internalBinaryWrite(message.flow.implicit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.PasswordOAuthFlow password = 4; */
        if (message.flow.oneofKind === "password")
            PasswordOAuthFlow.internalBinaryWrite(message.flow.password, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.OAuthFlows
 */
export const OAuthFlows = new OAuthFlows$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationCodeOAuthFlow$Type extends MessageType<AuthorizationCodeOAuthFlow> {
    constructor() {
        super("a2a.v1.AuthorizationCodeOAuthFlow", [
            { no: 1, name: "authorization_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<AuthorizationCodeOAuthFlow>): AuthorizationCodeOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizationUrl = "";
        message.tokenUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<AuthorizationCodeOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationCodeOAuthFlow): AuthorizationCodeOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authorization_url */ 1:
                    message.authorizationUrl = reader.string();
                    break;
                case /* string token_url */ 2:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 3:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 4:
                    this.binaryReadMap4(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: AuthorizationCodeOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AuthorizationCodeOAuthFlow["scopes"] | undefined, val: AuthorizationCodeOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.AuthorizationCodeOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AuthorizationCodeOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authorization_url = 1; */
        if (message.authorizationUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorizationUrl);
        /* string token_url = 2; */
        if (message.tokenUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 3; */
        if (message.refreshUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 4; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AuthorizationCodeOAuthFlow
 */
export const AuthorizationCodeOAuthFlow = new AuthorizationCodeOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientCredentialsOAuthFlow$Type extends MessageType<ClientCredentialsOAuthFlow> {
    constructor() {
        super("a2a.v1.ClientCredentialsOAuthFlow", [
            { no: 1, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<ClientCredentialsOAuthFlow>): ClientCredentialsOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tokenUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<ClientCredentialsOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientCredentialsOAuthFlow): ClientCredentialsOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token_url */ 1:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 2:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 3:
                    this.binaryReadMap3(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ClientCredentialsOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ClientCredentialsOAuthFlow["scopes"] | undefined, val: ClientCredentialsOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.ClientCredentialsOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ClientCredentialsOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token_url = 1; */
        if (message.tokenUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 2; */
        if (message.refreshUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 3; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ClientCredentialsOAuthFlow
 */
export const ClientCredentialsOAuthFlow = new ClientCredentialsOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImplicitOAuthFlow$Type extends MessageType<ImplicitOAuthFlow> {
    constructor() {
        super("a2a.v1.ImplicitOAuthFlow", [
            { no: 1, name: "authorization_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<ImplicitOAuthFlow>): ImplicitOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizationUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<ImplicitOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImplicitOAuthFlow): ImplicitOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authorization_url */ 1:
                    message.authorizationUrl = reader.string();
                    break;
                case /* string refresh_url */ 2:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 3:
                    this.binaryReadMap3(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ImplicitOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ImplicitOAuthFlow["scopes"] | undefined, val: ImplicitOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.ImplicitOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ImplicitOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authorization_url = 1; */
        if (message.authorizationUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorizationUrl);
        /* string refresh_url = 2; */
        if (message.refreshUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 3; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ImplicitOAuthFlow
 */
export const ImplicitOAuthFlow = new ImplicitOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordOAuthFlow$Type extends MessageType<PasswordOAuthFlow> {
    constructor() {
        super("a2a.v1.PasswordOAuthFlow", [
            { no: 1, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<PasswordOAuthFlow>): PasswordOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tokenUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<PasswordOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasswordOAuthFlow): PasswordOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token_url */ 1:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 2:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 3:
                    this.binaryReadMap3(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: PasswordOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PasswordOAuthFlow["scopes"] | undefined, val: PasswordOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.PasswordOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PasswordOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token_url = 1; */
        if (message.tokenUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 2; */
        if (message.refreshUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 3; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.PasswordOAuthFlow
 */
export const PasswordOAuthFlow = new PasswordOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageRequest$Type extends MessageType<SendMessageRequest> {
    constructor() {
        super("a2a.v1.SendMessageRequest", [
            { no: 4, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "request", kind: "message", jsonName: "message", T: () => Message, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "configuration", kind: "message", T: () => SendMessageConfiguration },
            { no: 3, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<SendMessageRequest>): SendMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        if (value !== undefined)
            reflectionMergePartial<SendMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageRequest): SendMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 4:
                    message.tenant = reader.string();
                    break;
                case /* a2a.v1.Message request = 1 [json_name = "message"] */ 1:
                    message.request = Message.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* a2a.v1.SendMessageConfiguration configuration */ 2:
                    message.configuration = SendMessageConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                case /* google.protobuf.Struct metadata */ 3:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.Message request = 1 [json_name = "message"]; */
        if (message.request)
            Message.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.SendMessageConfiguration configuration = 2; */
        if (message.configuration)
            SendMessageConfiguration.internalBinaryWrite(message.configuration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 3; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string tenant = 4; */
        if (message.tenant !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SendMessageRequest
 */
export const SendMessageRequest = new SendMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTaskRequest$Type extends MessageType<GetTaskRequest> {
    constructor() {
        super("a2a.v1.GetTaskRequest", [
            { no: 3, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "history_length", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetTaskRequest>): GetTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTaskRequest): GetTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 history_length */ 2:
                    message.historyLength = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 history_length = 2; */
        if (message.historyLength !== undefined)
            writer.tag(2, WireType.Varint).int32(message.historyLength);
        /* string tenant = 3; */
        if (message.tenant !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.GetTaskRequest
 */
export const GetTaskRequest = new GetTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTasksRequest$Type extends MessageType<ListTasksRequest> {
    constructor() {
        super("a2a.v1.ListTasksRequest", [
            { no: 9, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["a2a.v1.TaskState", TaskState, "TASK_STATE_"] },
            { no: 3, name: "page_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "history_length", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "last_updated_after", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "include_artifacts", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListTasksRequest>): ListTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.contextId = "";
        message.status = 0;
        message.pageToken = "";
        message.lastUpdatedAfter = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTasksRequest): ListTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 9:
                    message.tenant = reader.string();
                    break;
                case /* string context_id */ 1:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.TaskState status */ 2:
                    message.status = reader.int32();
                    break;
                case /* optional int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 4:
                    message.pageToken = reader.string();
                    break;
                case /* optional int32 history_length */ 5:
                    message.historyLength = reader.int32();
                    break;
                case /* int64 last_updated_after */ 6:
                    message.lastUpdatedAfter = reader.int64().toBigInt();
                    break;
                case /* optional bool include_artifacts */ 7:
                    message.includeArtifacts = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string context_id = 1; */
        if (message.contextId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.TaskState status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* optional int32 page_size = 3; */
        if (message.pageSize !== undefined)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        /* string page_token = 4; */
        if (message.pageToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pageToken);
        /* optional int32 history_length = 5; */
        if (message.historyLength !== undefined)
            writer.tag(5, WireType.Varint).int32(message.historyLength);
        /* int64 last_updated_after = 6; */
        if (message.lastUpdatedAfter !== 0n)
            writer.tag(6, WireType.Varint).int64(message.lastUpdatedAfter);
        /* optional bool include_artifacts = 7; */
        if (message.includeArtifacts !== undefined)
            writer.tag(7, WireType.Varint).bool(message.includeArtifacts);
        /* string tenant = 9; */
        if (message.tenant !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ListTasksRequest
 */
export const ListTasksRequest = new ListTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTasksResponse$Type extends MessageType<ListTasksResponse> {
    constructor() {
        super("a2a.v1.ListTasksResponse", [
            { no: 1, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Task, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "total_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<ListTasksResponse>): ListTasksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        message.nextPageToken = "";
        message.pageSize = 0;
        message.totalSize = 0;
        if (value !== undefined)
            reflectionMergePartial<ListTasksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTasksResponse): ListTasksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated a2a.v1.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                case /* int32 total_size */ 4:
                    message.totalSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTasksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated a2a.v1.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        /* int32 total_size = 4; */
        if (message.totalSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.totalSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ListTasksResponse
 */
export const ListTasksResponse = new ListTasksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelTaskRequest$Type extends MessageType<CancelTaskRequest> {
    constructor() {
        super("a2a.v1.CancelTaskRequest", [
            { no: 2, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelTaskRequest>): CancelTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CancelTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelTaskRequest): CancelTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 2:
                    message.tenant = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string tenant = 2; */
        if (message.tenant !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.CancelTaskRequest
 */
export const CancelTaskRequest = new CancelTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTaskPushNotificationConfigRequest$Type extends MessageType<GetTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.GetTaskPushNotificationConfigRequest", [
            { no: 2, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTaskPushNotificationConfigRequest>): GetTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTaskPushNotificationConfigRequest): GetTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 2:
                    message.tenant = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string tenant = 2; */
        if (message.tenant !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.GetTaskPushNotificationConfigRequest
 */
export const GetTaskPushNotificationConfigRequest = new GetTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTaskPushNotificationConfigRequest$Type extends MessageType<DeleteTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.DeleteTaskPushNotificationConfigRequest", [
            { no: 2, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTaskPushNotificationConfigRequest>): DeleteTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTaskPushNotificationConfigRequest): DeleteTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 2:
                    message.tenant = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string tenant = 2; */
        if (message.tenant !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.DeleteTaskPushNotificationConfigRequest
 */
export const DeleteTaskPushNotificationConfigRequest = new DeleteTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTaskPushNotificationConfigRequest$Type extends MessageType<SetTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.SetTaskPushNotificationConfigRequest", [
            { no: 4, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "config_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "config", kind: "message", T: () => TaskPushNotificationConfig, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<SetTaskPushNotificationConfigRequest>): SetTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.parent = "";
        message.configId = "";
        if (value !== undefined)
            reflectionMergePartial<SetTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTaskPushNotificationConfigRequest): SetTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 4:
                    message.tenant = reader.string();
                    break;
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string config_id */ 2:
                    message.configId = reader.string();
                    break;
                case /* a2a.v1.TaskPushNotificationConfig config */ 3:
                    message.config = TaskPushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string config_id = 2; */
        if (message.configId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.configId);
        /* a2a.v1.TaskPushNotificationConfig config = 3; */
        if (message.config)
            TaskPushNotificationConfig.internalBinaryWrite(message.config, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string tenant = 4; */
        if (message.tenant !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SetTaskPushNotificationConfigRequest
 */
export const SetTaskPushNotificationConfigRequest = new SetTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeToTaskRequest$Type extends MessageType<SubscribeToTaskRequest> {
    constructor() {
        super("a2a.v1.SubscribeToTaskRequest", [
            { no: 2, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeToTaskRequest>): SubscribeToTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SubscribeToTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeToTaskRequest): SubscribeToTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 2:
                    message.tenant = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeToTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string tenant = 2; */
        if (message.tenant !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SubscribeToTaskRequest
 */
export const SubscribeToTaskRequest = new SubscribeToTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTaskPushNotificationConfigRequest$Type extends MessageType<ListTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.ListTaskPushNotificationConfigRequest", [
            { no: 4, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListTaskPushNotificationConfigRequest>): ListTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        message.parent = "";
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTaskPushNotificationConfigRequest): ListTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 4:
                    message.tenant = reader.string();
                    break;
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* int32 page_size */ 2:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 3:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* int32 page_size = 2; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageSize);
        /* string page_token = 3; */
        if (message.pageToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pageToken);
        /* string tenant = 4; */
        if (message.tenant !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ListTaskPushNotificationConfigRequest
 */
export const ListTaskPushNotificationConfigRequest = new ListTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExtendedAgentCardRequest$Type extends MessageType<GetExtendedAgentCardRequest> {
    constructor() {
        super("a2a.v1.GetExtendedAgentCardRequest", [
            { no: 1, name: "tenant", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetExtendedAgentCardRequest>): GetExtendedAgentCardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenant = "";
        if (value !== undefined)
            reflectionMergePartial<GetExtendedAgentCardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExtendedAgentCardRequest): GetExtendedAgentCardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant */ 1:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExtendedAgentCardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant = 1; */
        if (message.tenant !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.GetExtendedAgentCardRequest
 */
export const GetExtendedAgentCardRequest = new GetExtendedAgentCardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageResponse$Type extends MessageType<SendMessageResponse> {
    constructor() {
        super("a2a.v1.SendMessageResponse", [
            { no: 1, name: "task", kind: "message", oneof: "payload", T: () => Task },
            { no: 2, name: "msg", kind: "message", jsonName: "message", oneof: "payload", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<SendMessageResponse>): SendMessageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SendMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageResponse): SendMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.Task task */ 1:
                    message.payload = {
                        oneofKind: "task",
                        task: Task.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).task)
                    };
                    break;
                case /* a2a.v1.Message msg = 2 [json_name = "message"] */ 2:
                    message.payload = {
                        oneofKind: "msg",
                        msg: Message.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).msg)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.Task task = 1; */
        if (message.payload.oneofKind === "task")
            Task.internalBinaryWrite(message.payload.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.Message msg = 2 [json_name = "message"]; */
        if (message.payload.oneofKind === "msg")
            Message.internalBinaryWrite(message.payload.msg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SendMessageResponse
 */
export const SendMessageResponse = new SendMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamResponse$Type extends MessageType<StreamResponse> {
    constructor() {
        super("a2a.v1.StreamResponse", [
            { no: 1, name: "task", kind: "message", oneof: "payload", T: () => Task },
            { no: 2, name: "msg", kind: "message", jsonName: "message", oneof: "payload", T: () => Message },
            { no: 3, name: "status_update", kind: "message", oneof: "payload", T: () => TaskStatusUpdateEvent },
            { no: 4, name: "artifact_update", kind: "message", oneof: "payload", T: () => TaskArtifactUpdateEvent }
        ]);
    }
    create(value?: PartialMessage<StreamResponse>): StreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamResponse): StreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.Task task */ 1:
                    message.payload = {
                        oneofKind: "task",
                        task: Task.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).task)
                    };
                    break;
                case /* a2a.v1.Message msg = 2 [json_name = "message"] */ 2:
                    message.payload = {
                        oneofKind: "msg",
                        msg: Message.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).msg)
                    };
                    break;
                case /* a2a.v1.TaskStatusUpdateEvent status_update */ 3:
                    message.payload = {
                        oneofKind: "statusUpdate",
                        statusUpdate: TaskStatusUpdateEvent.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).statusUpdate)
                    };
                    break;
                case /* a2a.v1.TaskArtifactUpdateEvent artifact_update */ 4:
                    message.payload = {
                        oneofKind: "artifactUpdate",
                        artifactUpdate: TaskArtifactUpdateEvent.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).artifactUpdate)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.Task task = 1; */
        if (message.payload.oneofKind === "task")
            Task.internalBinaryWrite(message.payload.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.Message msg = 2 [json_name = "message"]; */
        if (message.payload.oneofKind === "msg")
            Message.internalBinaryWrite(message.payload.msg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.TaskStatusUpdateEvent status_update = 3; */
        if (message.payload.oneofKind === "statusUpdate")
            TaskStatusUpdateEvent.internalBinaryWrite(message.payload.statusUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.TaskArtifactUpdateEvent artifact_update = 4; */
        if (message.payload.oneofKind === "artifactUpdate")
            TaskArtifactUpdateEvent.internalBinaryWrite(message.payload.artifactUpdate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.StreamResponse
 */
export const StreamResponse = new StreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTaskPushNotificationConfigResponse$Type extends MessageType<ListTaskPushNotificationConfigResponse> {
    constructor() {
        super("a2a.v1.ListTaskPushNotificationConfigResponse", [
            { no: 1, name: "configs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TaskPushNotificationConfig },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListTaskPushNotificationConfigResponse>): ListTaskPushNotificationConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configs = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListTaskPushNotificationConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTaskPushNotificationConfigResponse): ListTaskPushNotificationConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated a2a.v1.TaskPushNotificationConfig configs */ 1:
                    message.configs.push(TaskPushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTaskPushNotificationConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated a2a.v1.TaskPushNotificationConfig configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            TaskPushNotificationConfig.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ListTaskPushNotificationConfigResponse
 */
export const ListTaskPushNotificationConfigResponse = new ListTaskPushNotificationConfigResponse$Type();
/**
 * @generated ServiceType for protobuf service a2a.v1.A2AService
 */
export const A2AService = new ServiceType("a2a.v1.A2AService", [
    { name: "SendMessage", options: { "google.api.http": { post: "/message:send", body: "*", additionalBindings: [{ post: "/{tenant}/message:send", body: "*" }] } }, I: SendMessageRequest, O: SendMessageResponse },
    { name: "SendStreamingMessage", serverStreaming: true, options: { "google.api.http": { post: "/message:stream", body: "*", additionalBindings: [{ post: "/{tenant}/message:stream", body: "*" }] } }, I: SendMessageRequest, O: StreamResponse },
    { name: "GetTask", options: { "google.api.http": { get: "/{name=tasks/*}", additionalBindings: [{ get: "/{tenant}/{name=tasks/*}" }] }, "google.api.method_signature": ["name"] }, I: GetTaskRequest, O: Task },
    { name: "ListTasks", options: { "google.api.http": { get: "/tasks", additionalBindings: [{ get: "/{tenant}/tasks" }] } }, I: ListTasksRequest, O: ListTasksResponse },
    { name: "CancelTask", options: { "google.api.http": { post: "/{name=tasks/*}:cancel", body: "*", additionalBindings: [{ post: "/{tenant}/{name=tasks/*}:cancel", body: "*" }] } }, I: CancelTaskRequest, O: Task },
    { name: "SubscribeToTask", serverStreaming: true, options: { "google.api.http": { get: "/{name=tasks/*}:subscribe", additionalBindings: [{ get: "/{tenant}/{name=tasks/*}:subscribe" }] } }, I: SubscribeToTaskRequest, O: StreamResponse },
    { name: "SetTaskPushNotificationConfig", options: { "google.api.http": { post: "/{parent=tasks/*/pushNotificationConfigs}", body: "config", additionalBindings: [{ post: "/{tenant}/{parent=tasks/*/pushNotificationConfigs}", body: "config" }] }, "google.api.method_signature": ["parent,config"] }, I: SetTaskPushNotificationConfigRequest, O: TaskPushNotificationConfig },
    { name: "GetTaskPushNotificationConfig", options: { "google.api.http": { get: "/{name=tasks/*/pushNotificationConfigs/*}", additionalBindings: [{ get: "/{tenant}/{name=tasks/*/pushNotificationConfigs/*}" }] }, "google.api.method_signature": ["name"] }, I: GetTaskPushNotificationConfigRequest, O: TaskPushNotificationConfig },
    { name: "ListTaskPushNotificationConfig", options: { "google.api.http": { get: "/{parent=tasks/*}/pushNotificationConfigs", additionalBindings: [{ get: "/{tenant}/{parent=tasks/*}/pushNotificationConfigs" }] }, "google.api.method_signature": ["parent"] }, I: ListTaskPushNotificationConfigRequest, O: ListTaskPushNotificationConfigResponse },
    { name: "GetExtendedAgentCard", options: { "google.api.http": { get: "/extendedAgentCard", additionalBindings: [{ get: "/{tenant}/extendedAgentCard" }] } }, I: GetExtendedAgentCardRequest, O: AgentCard },
    { name: "DeleteTaskPushNotificationConfig", options: { "google.api.http": { delete: "/{name=tasks/*/pushNotificationConfigs/*}", additionalBindings: [{ delete: "/{tenant}/{name=tasks/*/pushNotificationConfigs/*}" }] }, "google.api.method_signature": ["name"] }, I: DeleteTaskPushNotificationConfigRequest, O: Empty }
]);
